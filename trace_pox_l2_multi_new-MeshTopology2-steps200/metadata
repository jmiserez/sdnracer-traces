{
  "additional_metadata": null,
  "argv": [
    "./simulator.py",
    "-c",
    "config/trace_pox_l2_multi_new.py"
  ],
  "cwd": "/home/ahassany/repos/jsts",
  "host": {
    "cpu_info": "Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz",
    "free": "total       used       free     shared    buffers     cached\nMem:       4045244     244444    3800800       5696      17008     126480\n-/+ buffers/cache:     100956    3944288\nSwap:      4192252          0    4192252",
    "name": "stsdev",
    "num_cores": "2",
    "uptime": "18:34:41 up  2:44,  2 users,  load average: 0.14, 0.05, 0.06"
  },
  "modules": {
    "hassel": {
      "branch": "HEAD",
      "commit": "31afb29fa66783f5a66765bc186509b65ffc023e",
      "diff": "",
      "status": "HEAD detached at 31afb29\nnothing to commit, working directory clean"
    },
    "pox": {
      "branch": "backport_l2_multi",
      "commit": "8bb0754f4b1c1e5eb830ef1e87b2bb4116f76286",
      "diff": "diff --git a/pox/forwarding/l2_multi_new.py b/pox/forwarding/l2_multi_new.py\nindex 020c781..b3b929a 100644\n--- a/pox/forwarding/l2_multi_new.py\n+++ b/pox/forwarding/l2_multi_new.py\n@@ -59,8 +59,8 @@ waiting_paths = {}\n FLOOD_HOLDDOWN = 5\n \n # Flow timeouts\n-FLOW_IDLE_TIMEOUT = 10\n-FLOW_HARD_TIMEOUT = 30\n+FLOW_IDLE_TIMEOUT = 10000\n+FLOW_HARD_TIMEOUT = 30000\n \n # How long is allowable to set up a path?\n PATH_SETUP_TIME = 4\n@@ -73,6 +73,7 @@ def _calc_paths ():\n   \"\"\"\n \n   def dump ():\n+    log.info(\"XXXXXX dumping path\")\n     for i in sws:\n       for j in sws:\n         a = path_map[i][j][0]\n@@ -89,7 +90,7 @@ def _calc_paths ():\n       path_map[k][j] = (1,None)\n     path_map[k][k] = (0,None) # distance, intermediate\n \n-  #dump()\n+  dump()\n \n   for k in sws:\n     for i in sws:\n@@ -102,8 +103,8 @@ def _calc_paths ():\n               # i -> k -> j is better than existing\n               path_map[i][j] = (ikj_dist, k)\n \n-  #print \"--------------------\"\n-  #dump()\n+  print \"--------------------\"\n+  dump()\n \n \n def _get_raw_path (src, dst):\n@@ -168,7 +169,7 @@ class WaitingPath (object):\n   \"\"\"\n   A path which is waiting for its path to be established\n   \"\"\"\n-  def __init__ (self, path, packet):\n+  def __init__ (self, path, packet, in_port):\n     \"\"\"\n     xids is a sequence of (dpid,xid)\n     first_switch is the DPID where the packet came from\n@@ -179,6 +180,7 @@ class WaitingPath (object):\n     self.first_switch = path[0][0].dpid\n     self.xids = set()\n     self.packet = packet\n+    self.in_port = in_port\n \n     if len(waiting_paths) > 1000:\n       WaitingPath.expire_waiting_paths()\n@@ -195,26 +197,21 @@ class WaitingPath (object):\n     \"\"\"\n     Called when a barrier has been received\n     \"\"\"\n+    \"\"\"\n+    Called when a barrier has been received\n+    \"\"\"\n     self.xids.discard((event.dpid,event.xid))\n     if len(self.xids) == 0:\n       # Done!\n       if self.packet:\n         log.debug(\"Sending delayed packet out %s\"\n                   % (dpidToStr(self.first_switch),))\n-        msg = of.ofp_packet_out(data=self.packet)\n-        if self.packet.dst == EthAddr(\"0:00:00:00:00:01\"):\n-          port = 1\n-        else:\n-          port = 2\n-        #msg.actions = [of.ofp_action_output(port=port)]\n-        #msg.actions = [of.ofp_action_output(data=self.packet, port=of.OFPP_TABLE)]\n         msg = of.ofp_packet_out(data=self.packet,\n             action=of.ofp_action_output(port=of.OFPP_TABLE))\n         core.openflow.sendToDPID(self.first_switch, msg)\n \n       core.l2_multi.raiseEvent(PathInstalled(self.path))\n \n-\n   @staticmethod\n   def expire_waiting_paths ():\n     packets = set(waiting_paths.values())\n@@ -251,34 +248,24 @@ class Switch (EventMixin):\n   def _install (self, switch, in_port, out_port, match, buf = NO_BUFFER):\n     #log.info(\"Installing in_port=%d, out_port=%d, type=%s,  match=%s, buf=%s\", in_port, out_port, type(out_port), match, buf)\n     log.info(\"XXX Installing flowmod on sw=%s, in_port=%d, out_port=%d, buf=%s\", dpidToStr(switch.dpid), in_port, out_port,buf)\n-    assert  out_port not in [65535, '65535']\n-    assert int(in_port) != 65535\n-    msg = of.ofp_flow_mod()\n+    msg = of.ofp_flow_mod(out_port=out_port)\n     msg.match = match\n     msg.match.in_port = in_port\n     msg.idle_timeout = FLOW_IDLE_TIMEOUT\n     msg.hard_timeout = FLOW_HARD_TIMEOUT\n     msg.actions.append(of.ofp_action_output(port = out_port))\n     msg.buffer_id = buf\n-    assert msg.match\n-    assert msg.match.in_port\n-    assert msg.idle_timeout\n-    assert msg.hard_timeout\n-    assert msg.actions\n-    assert msg.buffer_id\n-    #assert msg.cookie\n-    msg.out_port == out_port\n-    assert msg.priority\n-    #log.info(\"Sending msg %s\", msg)\n+    log.info(\"XXXX _install Sending msg %s\", msg)\n     switch.connection.send(msg)\n \n-  def _install_path (self, p, match, packet_in=None):\n-    wp = WaitingPath(p, packet_in)\n+  def _install_path (self, p, match, packet_in=None, in_port=None):\n+    wp = WaitingPath(p, packet_in, in_port)\n     for sw, in_port, out_port in p:\n       #log.info(\"Installing segment on switch: '%s', in_port=%d, outport='%d' and macth='%s'\", sw, in_port, out_port, match)\n       log.info(\"XXX Installing segment on switch: '%s', in_port=%d, outport='%d'\", sw, in_port, out_port)\n       self._install(sw, in_port, out_port, match)\n       msg = of.ofp_barrier_request()\n+      log.info(\"XXXX _install_path Sending msg %s\", msg)\n       sw.connection.send(msg)\n       wp.add_xid(sw.dpid,msg.xid)\n \n@@ -322,6 +309,7 @@ class Switch (EventMixin):\n         msg = of.ofp_packet_out()\n         msg.actions.append(of.ofp_action_output(port = event.port))\n         msg.data = e.pack()\n+        log.info(\"XXXX install_path Sending msg %s\", msg)\n         self.connection.send(msg)\n \n       return\n@@ -330,48 +318,56 @@ class Switch (EventMixin):\n         match.dl_src, match.dl_dst, match.dl_type, len(p))\n \n     # We have a path -- install it\n-    self._install_path(p, match, event.parsed)\n+    self._install_path(p, match, event.parsed, in_port=event.port)\n \n     # Now reverse it and install it backwards\n     # (we'll just assume that will work)\n     p = [(sw,out_port,in_port) for sw,in_port,out_port in p]\n-    self._install_path(p, match.flip())\n+    self._install_path(p, match.flip(), in_port=event.port)\n \n \n   def _handle_PacketIn (self, event):\n-    if event.port == 65535:\n-      log.warn(\"Ignoring event from of.OFPP_TABLE %s\", str(event))\n-      return\n+    packet = event.parsed\n+    assert event.port != 65535\n     def flood ():\n       \"\"\" Floods the packet \"\"\"\n       if self.is_holding_down:\n         log.warning(\"Not flooding -- holddown active\")\n+      log.debug(\"Flooding packet src=%s, dst=%s\", packet.src, packet.dst)\n       msg = of.ofp_packet_out()\n       # OFPP_FLOOD is optional; some switches may need OFPP_ALL\n       msg.actions.append(of.ofp_action_output(port = of.OFPP_FLOOD))\n       msg.buffer_id = event.ofp.buffer_id\n       msg.in_port = event.port\n+      log.info(\"XXXX _handle_PacketIn flood Sending msg %s\", msg)\n       self.connection.send(msg)\n \n     def drop ():\n       # Kill the buffer\n       if event.ofp.buffer_id is not None:\n+        log.debug(\"Killing packet at buffer src=%s, dst=%s\", packet.src, packet.dst)\n         msg = of.ofp_packet_out()\n         msg.buffer_id = event.ofp.buffer_id\n         event.ofp.buffer_id = None # Mark is dead\n         msg.in_port = event.port\n+        log.info(\"XXXX _handle_PacketIn drop Sending msg %s\", msg)\n         self.connection.send(msg)\n \n     packet = event.parsed\n-    log.info(\"XXXXX PACKET IN: dpid=%s, in_port: %d, src=%s, dst=%s\", dpidToStr(event.dpid), event.port, packet.src, packet.dst)\n+    log.info(\"PACKET IN: dpid=%s, in_port: %d, src=%s, dst=%s, buffer id: %s\", dpidToStr(event.dpid), event.port, packet.src, packet.dst, event.ofp.buffer_id)\n \n-    print \"LOC for\", packet.src, \" is\", event.port\n-    print \"But old is \", mac_map.get(packet.src)\n     loc = (self, event.port) # Place we saw this ethaddr\n     oldloc = mac_map.get(packet.src) # Place we last saw this ethaddr\n+    if loc[1] == 65535:\n+      log.debug(\"resting location\")\n+      loc = oldloc\n+      event.port = oldloc[1]\n+\n+    log.debug(\"Packet IN location %s and old location is %s\", loc, oldloc)\n \n     if packet.type == packet.LLDP_TYPE:\n-      drop()\n+      #drop()\n+      log.info(\"Ignoring LLDP packets\")\n       return\n \n     if oldloc is None:\n@@ -380,7 +376,7 @@ class Switch (EventMixin):\n         log.debug(\"Learned %s at %s.%i\", packet.src, loc[0], loc[1])\n     elif oldloc != loc:\n       # ethaddr seen at different place!\n-      if core.openflow_discovery.is_edge_port(loc[0].dpid, loc[1]):\n+      if core.openflow_discovery_new.is_edge_port(loc[0].dpid, loc[1]) and loc[1] != 65535:\n         # New place is another \"plain\" port (probably)\n         log.debug(\"%s moved from %s.%i to %s.%i?\", packet.src,\n                   dpidToStr(oldloc[0].dpid), oldloc[1],\n@@ -457,10 +453,10 @@ class l2_multi (EventMixin):\n     # Listen to dependencies\n     def startup ():\n       core.openflow.addListeners(self, priority=0)\n-      core.openflow_discovery.addListeners(self)\n+      core.openflow_discovery_new.addListeners(self)\n     #core.call_when_ready(startup, ('openflow','openflow_discovery'))\n     core.openflow.addListeners(self, priority=0)\n-    core.openflow_discovery.addListeners(self)\n+    core.openflow_discovery_new.addListeners(self)\n \n   def _handle_LinkEvent (self, event):\n     def flip (link):\n@@ -479,6 +475,7 @@ class l2_multi (EventMixin):\n     clear = of.ofp_flow_mod(command=of.OFPFC_DELETE)\n     for sw in switches.itervalues():\n       if sw.connection is None: continue\n+      log.info(\"XXXX _handle_LinkEvent clear Sending msg %s\", clear)\n       sw.connection.send(clear)\n     path_map.clear()\n \n@@ -488,9 +485,9 @@ class l2_multi (EventMixin):\n       if sw1 in adjacency[sw2]: del adjacency[sw2][sw1]\n \n       # But maybe there's another way to connect these...\n-      for ll in core.openflow_discovery.adjacency:\n+      for ll in core.openflow_discovery_new.adjacency:\n         if ll.dpid1 == l.dpid1 and ll.dpid2 == l.dpid2:\n-          if flip(ll) in core.openflow_discovery.adjacency:\n+          if flip(ll) in core.openflow_discovery_new.adjacency:\n             # Yup, link goes both ways\n             adjacency[sw1][sw2] = ll.port1\n             adjacency[sw2][sw1] = ll.port2\n@@ -503,7 +500,7 @@ class l2_multi (EventMixin):\n       if adjacency[sw1][sw2] is None:\n         # These previously weren't connected.  If the link\n         # exists in both directions, we consider them connected now.\n-        if flip(l) in core.openflow_discovery.adjacency:\n+        if flip(l) in core.openflow_discovery_new.adjacency:\n           # Yup, link goes both ways -- connected!\n           adjacency[sw1][sw2] = l.port1\n           adjacency[sw2][sw1] = l.port2\ndiff --git a/pox/lib/packet/lldp.py b/pox/lib/packet/lldp.py\nindex eb628ea..16608e4 100644\n--- a/pox/lib/packet/lldp.py\n+++ b/pox/lib/packet/lldp.py\n@@ -1,20 +1,17 @@\n-# Copyright 2011 James McCauley\n+# Copyright 2012 James McCauley\n # Copyright 2008 (C) Nicira, Inc.\n #\n-# This file is part of POX.\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at:\n #\n-# POX is free software: you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation, either version 3 of the License, or\n-# (at your option) any later version.\n+#     http://www.apache.org/licenses/LICENSE-2.0\n #\n-# POX is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with POX.  If not, see <http://www.gnu.org/licenses/>.\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n \n # This file is derived from the packet library in NOX, which was\n # developed by Nicira, Inc.\n@@ -57,14 +54,13 @@\n # 9-126 - reserved\n #\n # TODO:\n-#   Error handling (malformed packetswill definately cause this to\n-#   puke)\n+# Error handling (malformed packets will definately cause this to puke)\n #\n #======================================================================\n \n import struct\n import time\n-from packet_utils       import *\n+from packet_utils import *\n \n from packet_base import packet_base\n from pox.lib.addresses import EthAddr\n@@ -78,496 +74,470 @@ lg = logging.getLogger('packet')\n #======================================================================\n \n class lldp (packet_base):\n-    \"802.1 AB lldp pdu\"\n+  \"802.1 AB lldp pdu\"\n+\n+  # chassis ID min = 2 + 1 + 1\n+  # PORT    ID min = 2 + 1 + 1\n+  # TTL        min = 2 + 2\n+  # End        min = 2\n+  MIN_LEN = (4 + 4 + 4 + 2 )\n+\n+  #TODO: Remove these from here (they should be at module scope)?\n+  END_TLV         = 0\n+  CHASSIS_ID_TLV  = 1\n+  PORT_ID_TLV     = 2\n+  TTL_TLV         = 3\n+  PORT_DESC_TLV   = 4\n+  SYSTEM_NAME_TLV = 5\n+  SYSTEM_DESC_TLV = 6\n+  SYSTEM_CAP_TLV  = 7\n+  MANAGEMENT_ADDR_TLV = 8\n+  ORGANIZATIONALLY_SPECIFIC_TLV = 127\n+\n+  tlv_parsers = {}\n+\n+  def __init__ (self, raw=None, prev=None, **kw):\n+    packet_base.__init__(self)\n+\n+    self.prev = prev\n+\n+    self.next = None\n+    self.tlvs = []\n+\n+    if raw is not None:\n+      self.parse(raw)\n+\n+    self._init(kw)\n+\n+  def next_tlv(self, array):\n+\n+    if len(array) < 2:\n+      self.msg('(lldp tlv parse) warning TLV data too short to read '\n+               + 'type/len (%u)' % (len(array),))\n+      return\n+\n+    (typelen,) = struct.unpack(\"!H\",array[0:2])\n+\n+    type = typelen >> 9\n+    length = typelen & 0x01ff\n+\n+    if len(array) < length:\n+      self.msg('(lldp tlv parse) warning TLV data too short to parse (%u)'\n+               % (len(array),))\n+      return\n+\n+    if type in lldp.tlv_parsers:\n+      self.tlvs.append(lldp.tlv_parsers[type](array[0: 2 + length]))\n+      return 2 + length\n+    else:\n+      self.msg('(lldp tlv parse) warning unknown tlv type (%u)'\n+               % (type,))\n+      self.tlvs.append(unknown_tlv(array[0: 2 + length]))\n+      return 2 + length\n+\n+  def parse (self, raw):\n+    assert isinstance(raw, bytes)\n+    self.raw = raw\n+    dlen = len(raw)\n+    if dlen < lldp.MIN_LEN:\n+      self.msg('(lldp parse) warning LLDP packet data too short to parse '\n+               + 'header: data len %u' % (dlen,))\n+      return\n+\n+    # point to the beginning of the pdu\n+    pduhead = 0\n+\n+    # get Chassis ID\n+    ret = self.next_tlv(raw)\n+    if ret == None:\n+      self.msg( '(lldp parse) error parsing chassis ID tlv' )\n+      return\n+    pduhead += ret\n+    if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.CHASSIS_ID_TLV:\n+      self.msg( '(lldp parse) error CHASSIS ID TLV missing' )\n+      return\n+\n+    # get PORT ID\n+    ret = self.next_tlv(raw[pduhead:])\n+    if ret is None:\n+      self.msg( '(lldp parse) error parsing port ID TLV' )\n+      return\n+    pduhead += ret\n+    if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.PORT_ID_TLV:\n+      self.msg( '(lldp parse) error port ID TLV missing' )\n+      return\n+\n+    # get  TTL\n+    ret = self.next_tlv(raw[pduhead:])\n+    if ret == None:\n+      self.msg( '(lldp parse) error parsing TTL TLV' )\n+      return\n+    pduhead += ret\n+    if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.TTL_TLV:\n+      self.msg( '(lldp parse) error port TTL TLV missing' )\n+      return\n+\n+    # Loop over all other TLVs\n+    arr_len = len(raw)\n+    while True:\n+      ret = self.next_tlv(raw[pduhead:])\n+      if ret == None:\n+        self.msg( '(lldp parse) error parsing TLV' )\n+        return\n+      if self.tlvs[len(self.tlvs)-1].tlv_type == lldp.END_TLV:\n+        break\n+      if (pduhead + ret) >= arr_len:\n+        self.msg( '(lldp parse) error end of TLV list without END TLV' )\n+        return\n+      pduhead += ret\n+\n+    self.parsed = True\n+\n+  def add_tlv (self, tlv):\n+    self.tlvs.append(tlv)\n+\n+  def __str__ (self):\n+    lstr = ''\n+    for tlv in self.tlvs:\n+      lstr += str(tlv)\n+    return '[LLDP ' + lstr + ']'\n+\n+  def hdr (self, payload):\n+    packet = b''\n+    for tlv in self.tlvs:\n+      packet += tlv.pack()\n+    return packet\n \n-    # chassis ID min = 2 + 1 + 1\n-    # PORT    ID min = 2 + 1 + 1\n-    # TTL        min = 2 + 2\n-    # End        min = 2\n-    MIN_LEN = (4 + 4 + 4 + 2 )\n \n-    #TODO: Remove these from here (they should be at module scope)?\n-    END_TLV         = 0\n-    CHASSIS_ID_TLV  = 1\n-    PORT_ID_TLV     = 2\n-    TTL_TLV         = 3\n-    PORT_DESC_TLV   = 4\n-    SYSTEM_NAME_TLV = 5\n-    SYSTEM_DESC_TLV = 6\n-    SYSTEM_CAP_TLV  = 7\n-    MANAGEMENT_ADDR_TLV = 8\n-    ORGANIZATIONALLY_SPECIFIC_TLV = 127\n+#======================================================================\n+#                          TLV definitions\n+#======================================================================\n \n-    tlv_parsers = {}\n+#NOTE: As with a bunch of the packet library, it'd be nice if things\n+#      like TLVs inherited from some base class common to other\n+#      \"sub-packets\" (and maybe even packets).\n \n-    def __init__(self, raw=None, prev=None, **kw):\n-        packet_base.__init__(self)\n+class tlv_base (object):\n+  \"\"\"\n+  Supertype for LLDP TLVs\n+  \"\"\"\n+  pass\n \n-        self.prev = prev\n \n-        self.next = None\n-        self.tlvs = []\n+class simple_tlv (tlv_base):\n+  tlv_type = None # Purposely illegal\n \n-        if raw is not None:\n-            self.parse(raw)\n+  def __init__ (self, raw = None, **kw):\n+    self._init(kw)\n+    self.parsed   = False\n \n-        self._init(kw)\n+    if raw is not None:\n+      self.parse(raw)\n \n-    def next_tlv(self, array):\n+    self._init_helper(kw)\n \n-        if len(array) < 2:\n-            self.msg('(lldp tlv parse) warning TLV data too short to read type/len (%u)' % (len(array),))\n-            return\n+  def _init_helper (self, kw):\n+    if len(kw):\n+      if 'payload' in kw:\n+        self.payload = None\n+      initHelper(self, kw)\n+      self.parsed = True\n \n-        (typelen,) = struct.unpack(\"!H\",array[0:2])\n+  def parse (self, raw):\n+    # assume lldp has done the type/len checking\n+    (typelen,) = struct.unpack(\"!H\", raw[0:2])\n+    tlv_type = typelen >> 9\n+    if self.tlv_type is not None:\n+      assert self.tlv_type == tlv_type\n+    self.tlv_type = tlv_type\n \n-        type      = typelen >> 9\n-        length    = typelen & 0x01ff\n+    strlen = typelen & 0x01ff\n+\n+    data = raw[2:2+strlen]\n+    if len(data) < strlen:\n+      raise TruncatedException()\n \n-        if len(array) < length:\n-            self.msg( '(lldp tlv parse) warning TLV data too short to parse (%u)' % (len(array),))\n-            return\n+    self._parse_data(data)\n+    self.parsed = True\n \n-        if type in lldp.tlv_parsers:\n-            self.tlvs.append(lldp.tlv_parsers[type](array[0: 2 + length]))\n-            return 2 + length\n-        else:\n-            self.msg( '(lldp tlv parse) warning unknown tlv type (%u)' % (type,) )\n-            # TODO: unknown_tlv is an undefined variable! Check me in?\n-            self.tlvs.append(unknown_tlv(array[0: 2 + length]))\n-            return 2 + length\n-\n-    def parse(self, raw):\n-        assert isinstance(raw, bytes)\n-        self.raw = raw\n-        dlen = len(raw)\n-        if dlen < lldp.MIN_LEN:\n-            self.msg( '(lldp parse) warning LLDP packet data too short to parse header: data len %u' % (dlen,))\n-            return\n-\n-        # point to the beginning of the pdu\n-        pduhead = 0\n-\n-        # get Chassis ID\n-        ret = self.next_tlv(raw)\n-        if ret == None:\n-            self.msg( '(lldp parse) error parsing chassis ID tlv' )\n-            return\n-        pduhead += ret\n-        if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.CHASSIS_ID_TLV:\n-            self.msg( '(lldp parse) error CHASSIS ID TLV missing' )\n-            return\n-\n-        # get PORT ID\n-        ret = self.next_tlv(raw[pduhead:])\n-        if ret is None:\n-            self.msg( '(lldp parse) error parsing port ID TLV' )\n-            return\n-        pduhead += ret\n-        if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.PORT_ID_TLV:\n-            self.msg( '(lldp parse) error port ID TLV missing' )\n-            return\n-\n-        # get  TTL\n-        ret = self.next_tlv(raw[pduhead:])\n-        if ret == None:\n-            self.msg( '(lldp parse) error parsing TTL TLV' )\n-            return\n-        pduhead += ret\n-        if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.TTL_TLV:\n-            self.msg( '(lldp parse) error port TTL TLV missing' )\n-            return\n-\n-        # Loop over all other TLVs\n-        arr_len = len(raw)\n-        while True:\n-            ret = self.next_tlv(raw[pduhead:])\n-            if ret == None:\n-                self.msg( '(lldp parse) error parsing TLV' )\n-                return\n-            if self.tlvs[len(self.tlvs)-1].tlv_type == lldp.END_TLV:\n-                break\n-            if (pduhead + ret) >= arr_len:\n-                self.msg( '(lldp parse) error end of TLV list without END TLV' )\n-                return\n-            pduhead += ret\n-\n-        self.parsed = True\n-\n-    def add_tlv(self, tlv):\n-        self.tlvs.append(tlv)\n-\n-    def __str__(self):\n-        lstr = ''\n-        for tlv in self.tlvs:\n-            lstr += str(tlv)\n-        return lstr\n-\n-    def hdr(self, payload):\n-        packet = b''\n-        for tlv in self.tlvs:\n-            packet += tlv.pack()\n-        return packet\n+  @property\n+  def strlen (self):\n+    return self._data_len()\n \n+  def pack (self):\n+    typelen = self.tlv_type << 9\n+    data = self._pack_data()\n+    typelen |= (len(data) & 0x01ff)\n+    return struct.pack('!H', typelen) + data\n \n-#======================================================================\n-#                          TLV definitions\n-#======================================================================\n-        \n-class chassis_id:\n-    tlv_type = lldp.CHASSIS_ID_TLV\n-\n-    SUB_CHASSIS  = 1 # IETF RFC 2737\n-    SUB_IF_ALIAS = 2 # IETF RFC 2863\n-    SUB_PORT     = 3 # IETF RFC 2737\n-    SUB_MAC      = 4 # IEEE Std 802-2001\n-    SUB_NETWORK  = 5 #\n-    SUB_IF_NAME  = 6 # IETF RFC 2863\n-    SUB_LOCAL    = 7\n-\n-    subtype_to_str = {}\n-    subtype_to_str[SUB_CHASSIS]  = \"chassis\"\n-    subtype_to_str[SUB_IF_ALIAS] = \"interface alias\"\n-    subtype_to_str[SUB_PORT]     = \"port\"\n-    subtype_to_str[SUB_MAC]      = \"mac\"\n-    subtype_to_str[SUB_NETWORK]  = \"network\"\n-    subtype_to_str[SUB_IF_NAME]  = \"interface name\"\n-    subtype_to_str[SUB_LOCAL]    = \"local\"\n-\n-    # Construct from packet data\n-    def __init__(self, raw = None, **kw):\n-        self.parsed   = False\n-        self.strlen   = 0\n-        self.subtype  = 0\n-        self.id       = None\n-        self.arr      = None\n-        if raw is not None:\n-            self.arr = raw\n-            self.parse()\n-        initHelper(self, kw)\n-   \n-    def fill(self, _subtype, strval):\n-        self.strlen  = 1 + len(strval)\n-        self.subtype = _subtype\n-        self.id      = strval\n+  def __str__ (self):\n+    return \"<\" + self.__class__.__name__ + \">\"\n+\n+\n+  def _init (self, kw):\n+    \"\"\"\n+    Initialize subclass-specific fields\n+\n+    Override this.\n+    \"\"\"\n+    pass\n+\n+  def _data_len (self):\n+    \"\"\"\n+    Returns length of the TLV information string\n+\n+    Override this.\n+    \"\"\"\n+    return len(self._pack_data())\n+\n+  def _parse_data (self, data):\n+    \"\"\"\n+    Store TLV information string\n+\n+    Override this.\n+    \"\"\"\n+    self.payload = data\n+\n+  def _pack_data (self):\n+    \"\"\"\n+    Return TLV information string\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-\n-        self.tlv_type = typelen >> 9\n-        assert(self.tlv_type == 1)\n-        self.strlen = typelen & 0x01ff\n-        assert(self.strlen >= 2)\n-        (self.subtype,) = struct.unpack(\"!B\",self.arr[2:3])\n-        self.id = self.arr[3:]\n-        self.parsed = True\n-\n-    def hdr(self, payload):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.strlen & 0x01ff)\n-        pack_str = '!HB'+str(self.strlen-1)+'s'\n-        return struct.pack(pack_str, typelen, self.subtype, self.id)\n-\n-    def pack(self):\n-        packet = self.hdr(0)\n-        return packet\n-\n-    def __str__(self):\n-        if self.subtype == chassis_id.SUB_MAC:\n-            assert len(self.id) == 6\n-            id_str = str(EthAddr(self.id))\n-        else:\n-            id_str = \":\".join([\"%02x\" % (ord(x),) for x in self.id])\n-\n-        return ''.join(['<chasis ID:',id_str,'>'])\n-\n-class port_id:\n-    tlv_type = lldp.PORT_ID_TLV\n-\n-    SUB_IF_ALIAS = 1 # IETF RFC 2863\n-    SUB_PORT     = 2 # IETF RFC 2737\n-    SUB_MAC      = 3 # IEEE Std 802-2001\n-    SUB_NETWORK  = 4 #\n-    SUB_IF_NAME  = 5 # IETF RFC 2863\n-    SUB_CIRC_ID  = 6 # IETF RFC 3046\n-    SUB_LOCAL    = 7\n-\n-    subtype_to_str = {}\n-    subtype_to_str[SUB_IF_ALIAS] = \"interface alias\"\n-    subtype_to_str[SUB_PORT]     = \"port\"\n-    subtype_to_str[SUB_MAC]      = \"mac\"\n-    subtype_to_str[SUB_NETWORK]  = \"network\"\n-    subtype_to_str[SUB_IF_NAME]  = \"interface name\"\n-    subtype_to_str[SUB_CIRC_ID]  = \"agent circuit ID\"\n-    subtype_to_str[SUB_LOCAL]    = \"local\"\n-\n-    def __init__(self, raw = None, **kw):\n-        self.parsed = False\n-        self.subtype = 0\n-        self.id      = None\n-        self.arr     = raw\n-        if raw is not None:\n-            self.parse()\n-\n-    @property\n-    def strlen (self):\n-      return 1 + len(self.id)\n-\n-    def fill(self, subtype, strval):\n-        self.subtype = subtype\n-        self.id      = strval\n+    Override this.\n+    \"\"\"\n+    return self.payload\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-\n-        self.tlv_type = typelen >> 9\n-        assert(self.tlv_type == 2)\n-        strlen = typelen & 0x01ff\n-        assert(strlen >= 2)\n-        (self.subtype,) = struct.unpack(\"!B\",self.arr[2:3])\n-        self.id = self.arr[3:]\n-        assert strlen == 1 + len(self.id)\n-        parsed = True\n-\n-    def __str__(self):\n-        if self.subtype == chassis_id.SUB_MAC:\n-            assert len(self.id) == 6\n-            id_str = str(EthAddr(self.id))\n-        else:\n-            id_str = \":\".join([\"%02x\" % (ord(x),) for x in self.id])\n \n-        return ''.join(['<port ID:',id_str,'>'])\n+class unknown_tlv (simple_tlv):\n+  \"\"\"\n+  Unknown TLVs are parsed into this class\n+  \"\"\"\n+  tlv_type = None\n \n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.strlen & 0x01ff)\n-        pack_str = '!HB'+str(self.strlen-1)+'s'\n-        return struct.pack(pack_str, typelen, self.subtype, self.id)\n \n-class ttl:\n-    tlv_type = lldp.TTL_TLV\n+class chassis_id (simple_tlv):\n+  tlv_type = lldp.CHASSIS_ID_TLV\n \n-    def __init__(self, raw = None, **kw):\n-        self.parsed = False\n-        self.strlen  = 2\n-        self.ttl     = 0\n-        self.arr     = raw\n+  SUB_CHASSIS  = 1 # IETF RFC 2737\n+  SUB_IF_ALIAS = 2 # IETF RFC 2863\n+  SUB_PORT     = 3 # IETF RFC 2737\n+  SUB_MAC      = 4 # IEEE Std 802-2001\n+  SUB_NETWORK  = 5 #\n+  SUB_IF_NAME  = 6 # IETF RFC 2863\n+  SUB_LOCAL    = 7\n \n-        if raw is not None:\n-            self.parse()\n+  subtype_to_str = {}\n+  subtype_to_str[SUB_CHASSIS]  = \"chassis\"\n+  subtype_to_str[SUB_IF_ALIAS] = \"interface alias\"\n+  subtype_to_str[SUB_PORT]     = \"port\"\n+  subtype_to_str[SUB_MAC]      = \"mac\"\n+  subtype_to_str[SUB_NETWORK]  = \"network\"\n+  subtype_to_str[SUB_IF_NAME]  = \"interface name\"\n+  subtype_to_str[SUB_LOCAL]    = \"local\"\n \n-        initHelper(self, kw)\n+  def _init (self, kw):\n+    self.subtype  = 0\n+    self.id       = None\n \n-    def fill(self, ttl):\n-        self.ttl    = ttl\n+  def _parse_data (self, data):\n+    if len(data) < 2:\n+      raise MalformedException(\"TLV has invalid strlen\")\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-\n-        self.tlv_type = typelen >> 9\n-        assert(self.tlv_type == 3)\n-        self.strlen = typelen & 0x01ff\n-        if (self.strlen != 2):\n-            lg.info('(ttl tlv parse) length incorrect (should be 2) %u', self.strlen)\n-            return\n-        (self.ttl,) = struct.unpack(\"!H\",self.arr[2:4])\n-        self.parsed = True\n-\n-    def __str__(self):\n-        return ''.join(['<ttl:',str(self.ttl),'>'])\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.strlen & 0x01ff)\n-        pack_str = '!HB'+str(self.strlen-1)+'s'\n-        return struct.pack('!HH', typelen, self.ttl)\n-\n-class end_tlv:\n-    tlv_type = lldp.END_TLV\n-\n-    def __init__(self, raw = None):\n-        self.parsed = False\n-        self.strlen  = 0\n-        self.arr     = raw \n-        if raw is not None:\n-            self.parse()\n+    (self.subtype,) = struct.unpack(\"!B\",data[0:1])\n+    self.id = data[1:]\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-        self.tlv_type = typelen >> 9\n-        assert(self.tlv_type == lldp.END_TLV)\n-        self.strlen = typelen & 0x01ff\n-        if self.strlen != 0:\n-            lg.info('(tl end parse) length incorrect (should be 0) %u', self.strlen)\n-            return\n-        self.parsed = True\n-\n-    def __str__(self):\n-        return '<tlv end>'\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.strlen & 0x01ff)\n-        return struct.pack('!H', typelen)\n-\n-class basic_tlv (object):\n-    #tlv_type = <type>\n-    def __init__(self, raw = None):\n-        self.parsed = False\n-        self.len    = 0\n-        self.arr    = raw\n-        self.next   = b''\n-        if raw is not None:\n-            self.parse()\n-\n-    def fill(self, strval):\n-        self.len  = len(strval)\n-        self.next = strval\n+  def _pack_data (self):\n+    return struct.pack(\"!B\", self.subtype) + self.id\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-        self.tlv_type = typelen >> 9\n-        self.len  = typelen & 0x01ff\n-        self.next = self.arr[2:]\n-        self.parsed = True\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.len & 0x01ff)\n-        return struct.pack('!H', typelen) + self.next\n-\n-class unknown_tlv (basic_tlv):\n-    tlv_type = None\n-\n-class system_description (basic_tlv):\n-    tlv_type = lldp.SYSTEM_DESC_TLV\n-\n-class management_address (object):\n-    tlv_type = lldp.MANAGEMENT_ADDR_TLV\n-\n-    def __init__ (self, raw = None):\n-        self.address_subtype = 0\n-        self.address = b''\n-        self.interface_numbering_subtype = 0\n-        self.interface_number = 0\n-        self.object_identifier = b''\n-\n-        if raw is not None:\n-            self.parse(raw)\n-\n-    def parse (self, data):\n-        typelen = struct.unpack(\"!H\",data[0:2])[0]\n-        self.tlv_type = typelen >> 9\n-        length  = typelen & 0x01ff\n-\n-        asl = ord(data[2]) - 1\n-        self.address_subtype = ord(data[3])\n-        self.address = data[4:4+asl]\n-\n-        self.interface_numbering_subtype = ord(data[4+asl])\n-        self.interface_number = struct.unpack(\"!L\",\n-                                              data[4+asl+1:4+asl+1+4])[0]\n-        osl = ord(data[9+asl])\n-        self.object_identifier = data[9+asl+1:9+asl+1+osl]\n-\n-    def __len__ (self):\n-        return 2+1+1+len(self.address)+1+4+1+len(self.object_identifier)\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | ((len(self)-2) & 0x01ff)\n-        r = struct.pack('!H', typelen)\n-        r += struct.pack('!BB', len(self.address)+1, self.address_subtype)\n-        r += self.address\n-        r += struct.pack(\"!BLB\", self.interface_numbering_subtype,\n-                         self.interface_number,\n-                         len(self.object_identifier))\n-        r += self.object_identifier\n-        return r\n-\n-class system_name (basic_tlv):\n-    tlv_type = lldp.SYSTEM_NAME_TLV\n-\n-class organizationally_specific (basic_tlv):\n-    tlv_type = lldp.ORGANIZATIONALLY_SPECIFIC_TLV\n-    def __init__ (self, raw = None):\n-        self.oui = '\\x00\\x00\\x00'\n-        self.subtype = 0\n-        self.next = bytes()\n-        basic_tlv.__init__(self, raw)\n-      \n-    def parse (self):\n-        basic_tlv.parse(self)\n-        (self.oui,self.subtype) = struct.unpack(\"3sB\", self.next[0:4])\n-        self.next = self.next[4:]\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.len & 0x01ff)\n-        return struct.pack('!H3sB', typelen, self.oui, self.subtype) + self.next\n-\n-class port_description (basic_tlv):\n-    tlv_type = lldp.PORT_DESC_TLV\n-\n-class system_capabilities (basic_tlv):\n-    tlv_type = lldp.SYSTEM_CAP_TLV\n-\n-    cap_names = [\"Other\", \"Repeater\", \"Bridge\", \"WLAN Access Point\",\n-                 \"Router\", \"Telephone\", \"DOCSIS cable device\",\n-                 \"Station Only\"]\n-\n-    def __init__ (self, raw = None):\n-        self.caps = [False] * 16\n-        self.enabled_caps = [False] * 16\n-        basic_tlv.__init__(self, raw)\n-      \n-    def parse (self):\n-        basic_tlv.parse(self)\n-        (cap,en) = struct.unpack(\"!HH\", self.next)\n-        del self.caps[:]\n-        del self.enabled_caps[:]\n-        for i in range(0, 16):\n-            self.caps.append(True if (cap and (1 << i)) else False)\n-            self.enabled_caps.append(True if (en and (1 << i)) else False)\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.len & 0x01ff)\n-        cap = 0\n-        en = 0\n-        for i in range(0, 16):\n-            if self.caps[i]: cap |= (1 << i)\n-            if self.enabled_caps[i]: en |= (1 << i)\n-        return struct.pack('!HHH', typelen, cap, en)\n-\n-    def __str__ (self):\n-        r = []\n-        for i in range(0, 16):\n-            if self.caps[i]:\n-                if i < len(self.cap_names):\n-                    s = self.cap_names[i]\n-                else:\n-                    s = \"Capability \" + str(i)\n-                s += \":\" + (\"On\" if self.enabled_caps[i] else \"Off\")\n-                r.append(s)\n-        return \"<Capabilities: \" + ', '.join(r) + \">\"\n+  def __str__ (self):\n+    if self.subtype == chassis_id.SUB_MAC:\n+      assert len(self.id) == 6\n+      id_str = str(EthAddr(self.id))\n+    else:\n+      id_str = \":\".join([\"%02x\" % (ord(x),) for x in self.id])\n+\n+    return ''.join(['<chasis ID:',id_str,'>'])\n+\n+\n+class port_id (simple_tlv):\n+  tlv_type = lldp.PORT_ID_TLV\n+\n+  SUB_IF_ALIAS = 1 # IETF RFC 2863\n+  SUB_PORT     = 2 # IETF RFC 2737\n+  SUB_MAC      = 3 # IEEE Std 802-2001\n+  SUB_NETWORK  = 4 #\n+  SUB_IF_NAME  = 5 # IETF RFC 2863\n+  SUB_CIRC_ID  = 6 # IETF RFC 3046\n+  SUB_LOCAL    = 7\n+\n+  subtype_to_str = {}\n+  subtype_to_str[SUB_IF_ALIAS] = \"interface alias\"\n+  subtype_to_str[SUB_PORT]     = \"port\"\n+  subtype_to_str[SUB_MAC]      = \"mac\"\n+  subtype_to_str[SUB_NETWORK]  = \"network\"\n+  subtype_to_str[SUB_IF_NAME]  = \"interface name\"\n+  subtype_to_str[SUB_CIRC_ID]  = \"agent circuit ID\"\n+  subtype_to_str[SUB_LOCAL]    = \"local\"\n+\n+  def _init (self, kw):\n+    self.subtype = 0\n+    self.id      = None\n+\n+  def _parse_data (self, data):\n+    if len(data) < 2:\n+      raise MalformedException(\"TLV has invalid strlen\")\n+\n+    (self.subtype,) = struct.unpack(\"!B\",data[0:1])\n+    self.id = data[1:]\n+\n+  def __str__ (self):\n+    if self.subtype == chassis_id.SUB_MAC:\n+      assert len(self.id) == 6\n+      id_str = str(EthAddr(self.id))\n+    else:\n+      id_str = \":\".join([\"%02x\" % (ord(x),) for x in self.id])\n+\n+    return ''.join(['<port ID:',id_str,'>'])\n+\n+  def _pack_data (self):\n+    return struct.pack(\"!B\", self.subtype) + self.id\n+\n+\n+class ttl (simple_tlv):\n+  tlv_type = lldp.TTL_TLV\n+\n+  def _init (self, kw):\n+    self.ttl = 0\n+\n+  def _parse_data (self, data):\n+    if len(data) != 2:\n+      raise MalformedException(\"TLV has invalid strlen (!= 2)\")\n+    (self.ttl,) = struct.unpack(\"!H\",data[0:2])\n+\n+  def __str__ (self):\n+    return ''.join(['<ttl:',str(self.ttl),'>'])\n+\n+  def _pack_data (self):\n+    return struct.pack('!H', self.ttl)\n+\n+\n+class end_tlv (simple_tlv):\n+  tlv_type = lldp.END_TLV\n+\n+  def _parse_data (self, data):\n+    if len(data) != 0:\n+      raise MalformedException(\"TLV has invalid strlen (!= 0)\")\n+\n+  def __str__ (self):\n+    return '<tlv end>'\n+\n+  def _pack_data (self):\n+    return b''\n+\n+\n+class system_description (simple_tlv):\n+  tlv_type = lldp.SYSTEM_DESC_TLV\n+\n+\n+class management_address (simple_tlv):\n+  tlv_type = lldp.MANAGEMENT_ADDR_TLV\n+\n+  def _init (self, kw):\n+    self.address_subtype = 0\n+    self.address = b''\n+    self.interface_numbering_subtype = 0\n+    self.interface_number = 0\n+    self.object_identifier = b''\n+\n+  def _parse_data (self, data):\n+    asl = ord(data[0]) - 1\n+    self.address_subtype = ord(data[1])\n+    self.address = data[2:2+asl]\n+\n+    self.interface_numbering_subtype = ord(data[2+asl])\n+    self.interface_number = struct.unpack(\"!L\",\n+                                      data[2+asl+1:2+asl+1+4])[0]\n+    osl = ord(data[7+asl])\n+    self.object_identifier = data[7+asl+1:7+asl+1+osl]\n+\n+  def _data_len (self):\n+    return 1+1+len(self.address)+1+4+1+len(self.object_identifier)\n+\n+  def _pack_data (self):\n+    r = struct.pack('!BB', len(self.address)+1, self.address_subtype)\n+    r += self.address\n+    r += struct.pack(\"!BLB\", self.interface_numbering_subtype,\n+                     self.interface_number,\n+                     len(self.object_identifier))\n+    r += self.object_identifier\n+    return r\n+\n+\n+class system_name (simple_tlv):\n+  tlv_type = lldp.SYSTEM_NAME_TLV\n+\n+\n+class organizationally_specific (simple_tlv):\n+  tlv_type = lldp.ORGANIZATIONALLY_SPECIFIC_TLV\n+\n+  def _init (self, kw):\n+    self.oui = '\\x00\\x00\\x00'\n+    self.subtype = 0\n+    self.payload = b''\n+\n+  def _parse_data (self, data):\n+    (self.oui,self.subtype) = struct.unpack(\"3sB\", data[0:4])\n+    self.payload = data[4:]\n+\n+  def _pack_data (self):\n+    return struct.pack('!3sB', self.oui, self.subtype) + self.payload\n+\n+\n+class port_description (simple_tlv):\n+  tlv_type = lldp.PORT_DESC_TLV\n+\n+\n+class system_capabilities (simple_tlv):\n+  tlv_type = lldp.SYSTEM_CAP_TLV\n+\n+  cap_names = [\"Other\", \"Repeater\", \"Bridge\", \"WLAN Access Point\",\n+         \"Router\", \"Telephone\", \"DOCSIS cable device\",\n+         \"Station Only\"]\n+\n+  def _init (self, kw):\n+    self.caps = [False] * 16\n+    self.enabled_caps = [False] * 16\n+\n+  def _parse_data (self, data):\n+    (cap,en) = struct.unpack(\"!HH\", data)\n+    del self.caps[:]\n+    del self.enabled_caps[:]\n+    for i in range(0, 16):\n+      self.caps.append(True if (cap & (1 << i)) else False)\n+      self.enabled_caps.append(True if (en & (1 << i)) else False)\n+\n+  def _pack_data (self):\n+    cap = 0\n+    en = 0\n+    for i in range(0, 16):\n+      if self.caps[i]: cap |= (1 << i)\n+      if self.enabled_caps[i]: en |= (1 << i)\n+    return struct.pack('!HH', cap, en)\n+\n+  def __str__ (self):\n+    r = []\n+    for i in range(0, 16):\n+      if self.caps[i]:\n+        if i < len(self.cap_names):\n+            s = self.cap_names[i]\n+        else:\n+            s = \"Capability \" + str(i)\n+        s += \":\" + (\"On\" if self.enabled_caps[i] else \"Off\")\n+        r.append(s)\n+    return \"<Capabilities: \" + ', '.join(r) + \">\"\n \n \n # Add parsers to main lldp class\n for t in [chassis_id, port_id, ttl, system_name, system_description,\n-          end_tlv, organizationally_specific, port_description,\n-          system_capabilities, management_address]:\n-    lldp.tlv_parsers[t.tlv_type] = t\n+      end_tlv, organizationally_specific, port_description,\n+      system_capabilities, management_address]:\n+  lldp.tlv_parsers[t.tlv_type] = t\ndiff --git a/pox/lib/revent/revent.py b/pox/lib/revent/revent.py\nindex e93e2fa..3563efb 100644\n--- a/pox/lib/revent/revent.py\n+++ b/pox/lib/revent/revent.py\n@@ -266,6 +266,8 @@ class EventMixin (object):\n       event = eventType(*args, **kw)\n       args = ()\n       kw = {}\n+      if not hasattr(event, 'source'):\n+        print \"XXX\", dir(event)\n       if event.source is None:\n         event.source = self\n     #print \"raise\",event,eventType\ndiff --git a/pox/openflow/connection_arbiter.py b/pox/openflow/connection_arbiter.py\nindex 6be3d30..8f71e4e 100644\n--- a/pox/openflow/connection_arbiter.py\n+++ b/pox/openflow/connection_arbiter.py\n@@ -63,6 +63,10 @@ class OpenFlowNexus (EventMixin):\n     self._connections = {}#weakref.WeakValueDictionary() # DPID -> Connection\n     self.listenTo(core)\n \n+  @property\n+  def connections (self):\n+    return self._connections\n+\n   def getConnection (self, dpid):\n     \"\"\"\n     Get the Connection object associated with a DPID.\ndiff --git a/pox/openflow/discovery_new.py b/pox/openflow/discovery_new.py\nindex f3710de..8aa7077 100644\n--- a/pox/openflow/discovery_new.py\n+++ b/pox/openflow/discovery_new.py\n@@ -78,6 +78,10 @@ class LLDPSender (object):\n     self._ttl = ttl\n     self._send_cycle_time = send_cycle_time\n     #core.listen_to_dependencies(self)\n+    #core.listenTo(core.openflow, prefix='openflow')\n+    core.openflow.addListenerByName(\"PortStatus\", self._handle_openflow_PortStatus)\n+    core.openflow.addListenerByName(\"ConnectionUp\", self._handle_openflow_ConnectionUp)\n+    core.openflow.addListenerByName(\"ConnectionDown\", self._handle_openflow_ConnectionDown)\n \n   def _handle_openflow_PortStatus (self, event):\n     \"\"\"\n@@ -165,6 +169,7 @@ class LLDPSender (object):\n     Create an ofp_packet_out containing a discovery packet\n     \"\"\"\n     eth = self._create_discovery_packet(dpid, port_num, port_addr, self._ttl)\n+    log.debug(\"Created discovery packet dpid=%s, port_num=%s, port_addr=%s, self._ttl=%s\", dpid, port_num, port_addr, self._ttl)\n     po = of.ofp_packet_out(action = of.ofp_action_output(port=port_num))\n     po.data = eth.pack()\n     return po.pack()\n@@ -206,6 +211,7 @@ class LinkEvent (Event):\n   Link up/down event\n   \"\"\"\n   def __init__ (self, add, link, event = None):\n+    Event.__init__(self)\n     self.link = link\n     self.added = add\n     self.removed = not add\n@@ -259,7 +265,7 @@ class Discovery (EventMixin):\n     LinkEvent,\n   ])\n \n-  _core_name = \"openflow_discovery\" # we want to be core.openflow_discovery\n+  _core_name = \"openflow_discovery_new\" # we want to be core.openflow_discovery\n \n   Link = Link\n \n@@ -277,8 +283,21 @@ class Discovery (EventMixin):\n     #core.listen_to_dependencies(self,\n     #    listen_args={'openflow':{'priority':0xffffffff}})\n \n+    #self.listenTo(core.openflow, prefix='openflow', listen_args={'openflow':{'priority':0xffffffff}})\n+    if core.hasComponent(\"openflow\"):\n+      log.debug(\"Listening to openflow\")\n+      self.listenTo(core.openflow, prefix='openflow', priority=0xffffffff)\n+    else:\n+      # We'll wait for openflow to come up\n+      log.debug(\"Listening to core\")\n+      self.listenTo(core)\n     Timer(self._timeout_check_period, self._expire_links, recurring=True)\n \n+  def _handle_ComponentRegistered (self, event):\n+    if event.name == \"openflow\":\n+      self.listenTo(core.openflow, prefix='openflow', priority=0xffffffff)\n+      return EventRemove # We don't need this listener anymore\n+\n   @property\n   def send_cycle_time (self):\n     return self._link_timeout / 2.0\n@@ -333,15 +352,20 @@ class Discovery (EventMixin):\n     \"\"\"\n     Receive and process LLDP packets\n     \"\"\"\n-\n     packet = event.parsed\n+    log.info(\"Packet in src: %s, dst: %s\", packet.src, packet.dst)\n \n-    if (packet.effective_ethertype != pkt.ethernet.LLDP_TYPE\n+    if (packet.type != pkt.ethernet.LLDP_TYPE\n         or packet.dst != pkt.ETHERNET.NDP_MULTICAST):\n-      if not self._eat_early_packets: return\n-      if not event.connection.connect_time: return\n+      if not self._eat_early_packets:\n+        log.debug(\"No eat\")\n+        return\n+      if not event.connection.connect_time:\n+        log.debug(\"connect time\")\n+        return\n       enable_time = time.time() - self.send_cycle_time - 1\n       if event.connection.connect_time > enable_time:\n+        log.debug(\"connect_time > enable_time\")\n         return EventHalt\n       return\n \n@@ -352,6 +376,8 @@ class Discovery (EventMixin):\n         msg.buffer_id = event.ofp.buffer_id\n         msg.in_port = event.port\n         event.connection.send(msg)\n+      else:\n+        log.debug(\"Not dropping LLDP because buffer id is %s\", event.ofp.buffer_id)\n \n     lldph = packet.find(pkt.lldp)\n     if lldph is None or not lldph.parsed:\n@@ -446,6 +472,7 @@ class Discovery (EventMixin):\n     link = Discovery.Link(originatorDPID, originatorPort, event.dpid,\n                           event.port)\n \n+    log.info(\"Link %s\", link)\n     if link not in self.adjacency:\n       self.adjacency[link] = time.time()\n       log.info('link detected: %s', link)\n@@ -458,6 +485,7 @@ class Discovery (EventMixin):\n \n   def _delete_links (self, links):\n     for link in links:\n+      log.info('link deleted: %s', link)\n       self.raiseEventNoErrors(LinkEvent, False, link)\n     for link in links:\n       self.adjacency.pop(link, None)\n@@ -484,5 +512,10 @@ def launch (no_flow = False, explicit_drop = True, link_timeout = None,\n   core.registerNew(Discovery, explicit_drop=explicit_drop,\n                    install_flow=install_flow, link_timeout=link_timeout,\n                    eat_early_packets=eat_early_packets)\n+  #d = Discovery(explicit_drop=explicit_drop,\n+  #                 install_flow=install_flow, link_timeout=link_timeout,\n+  #                 eat_early_packets=eat_early_packets)\n+  #core.register(d.__class__._core_name, d)\n \n   core.SpanningTreeNew.start_spanning_tree()\n+\ndiff --git a/pox/openflow/libopenflow_01.py b/pox/openflow/libopenflow_01.py\nindex 8c72ebd..e4f3117 100644\n--- a/pox/openflow/libopenflow_01.py\n+++ b/pox/openflow/libopenflow_01.py\n@@ -3013,7 +3013,7 @@ class ofp_packet_out (ofp_header):\n     self.buffer_id = -1\n     self.in_port = OFPP_NONE\n     self.actions = []\n-    self._data = ''\n+    self._data = b''\n \n     # ofp_flow_mod and ofp_packet_out do some special handling of 'actions'...\n \n@@ -3026,7 +3026,7 @@ class ofp_packet_out (ofp_header):\n     # Allow use of actions=<a single action> for kw args.\n     if not hasattr(self.actions, '__getitem__'):\n       self.actions = [self.actions]\n-\n+  \"\"\"\n   def _set_data(self, data):\n     assert_type(\"data\", data, (packet_base, str))\n     if data is None:\n@@ -3038,9 +3038,39 @@ class ofp_packet_out (ofp_header):\n   def _get_data(self):\n     return self._data\n   data = property(_get_data, _set_data)\n+  \"\"\"\n+  @property\n+  def data (self):\n+    return self._data\n+  @data.setter\n+  def data (self, data):\n+    if data is None:\n+      self._data = b''\n+    elif isinstance(data, packet_base):\n+      self._data = data.pack()\n+    elif isinstance(data, ofp_packet_in):\n+      # Enable you to easily resend a packet\n+      self._data = b''\n+      self.buffer_id = data.buffer_id\n+      if self.buffer_id is None:\n+        #TODO: It'd be nice to log and then ignore if data is incomplete\n+        #      Unfortunately, we currently have no logging in here, so we\n+        #      assert instead which is a either too drastic or too quiet.\n+        assert data.is_complete\n+        self._data = data._data\n+      self.in_port = data.in_port\n+    elif isinstance(data, bytes):\n+      self._data = data\n+    assert assert_type(\"data\", self._data, (bytes,))\n+\n+  def _validate (self):\n+    if self.buffer_id is not None and self.data != b'':\n+      return \"can not have both buffer_id and data set\"\n+    return None\n+\n \n   def _assert (self):\n-    if self.buffer_id != -1 and self.data != '':\n+    if self.buffer_id != -1 and self.data != b'':\n       return \"can not have both buffer_id and data set\"\n     return True\n \ndiff --git a/pox/openflow/spanning_tree_new.py b/pox/openflow/spanning_tree_new.py\nindex 86e812a..cfcaf26 100644\n--- a/pox/openflow/spanning_tree_new.py\n+++ b/pox/openflow/spanning_tree_new.py\n@@ -58,7 +58,7 @@ def _calc_spanning_tree ():\n   adj = defaultdict(lambda:defaultdict(lambda:[]))\n   switches = set()\n   # Add all links and switches\n-  for l in core.openflow_discovery.adjacency:\n+  for l in core.openflow_discovery_new.adjacency:\n     adj[l.dpid1][l.dpid2].append(l)\n     switches.add(l.dpid1)\n     switches.add(l.dpid2)\n@@ -73,7 +73,7 @@ def _calc_spanning_tree ():\n       assert s1 is not s2\n       good = False\n       for l in adj[s1][s2]:\n-        if flip(l) in core.openflow_discovery.adjacency:\n+        if flip(l) in core.openflow_discovery_new.adjacency:\n           # This is a good one\n           adj[s1][s2] = l.port1\n           adj[s2][s1] = l.port2\n@@ -132,13 +132,14 @@ _hold_down = False\n \n \n def _handle_ConnectionUp (event):\n+  log.debug(\"Spanning _handle_ConnectionUp\")\n   # When a switch connects, forget about previous port states\n   _prev[event.dpid].clear()\n \n   if _noflood_by_default:\n     con = event.connection\n     log.debug(\"Disabling flooding for %i ports\", len(con.ports))\n-    for p in con.ports.itervalues():\n+    for p in con.features.ports:\n       if p.port_no >= of.OFPP_MAX: continue\n       _prev[con.dpid][p.port_no] = False\n       pm = of.ofp_port_mod(port_no=p.port_no,\n@@ -149,13 +150,13 @@ def _handle_ConnectionUp (event):\n     _invalidate_ports(con.dpid)\n \n   if _hold_down:\n-    t = Timer(core.openflow_discovery.send_cycle_time + 1, _update_tree,\n+    t = Timer(core.openflow_discovery_new.send_cycle_time + 1, _update_tree,\n               kw={'force_dpid':event.dpid})\n \n \n def _handle_LinkEvent (event):\n   # When links change, update spanning tree\n-\n+  log.debug(\"Spanning _handle_LinkEvent\")\n   (dp1,p1),(dp2,p2) = event.link.end\n   if _prev[dp1][p1] is False:\n     if _prev[dp2][p2] is False:\n@@ -181,7 +182,7 @@ def _update_tree (force_dpid = None):\n   # Connections born before this time are old enough that a complete\n   # discovery cycle should have completed (and, thus, all of their\n   # links should have been discovered).\n-  enable_time = time.time() - core.openflow_discovery.send_cycle_time - 1\n+  enable_time = time.time() - core.openflow_discovery_new.send_cycle_time - 1\n \n   # Now modify ports as needed\n   try:\n@@ -201,11 +202,11 @@ def _update_tree (force_dpid = None):\n             continue\n \n       tree_ports = [p[1] for p in ports]\n-      for p in con.ports.itervalues():\n+      for p in con.features.ports:\n         if p.port_no < of.OFPP_MAX:\n           flood = p.port_no in tree_ports\n           if not flood:\n-            if core.openflow_discovery.is_edge_port(sw, p.port_no):\n+            if core.openflow_discovery_new.is_edge_port(sw, p.port_no):\n               flood = True\n           if _prev[sw][p.port_no] is flood:\n             #print sw,p.port_no,\"skip\",\"(\",flood,\")\"\n@@ -271,7 +272,7 @@ class SpanningTreeNew (EventMixin):\n   def start_spanning_tree (self):\n     print \"XXXX spanning tree is up\"\n     core.openflow.addListenerByName(\"ConnectionUp\", _handle_ConnectionUp)\n-    core.openflow_discovery.addListenerByName(\"LinkEvent\", _handle_LinkEvent)\n+    core.openflow_discovery_new.addListenerByName(\"LinkEvent\", _handle_LinkEvent)\n     log.debug(\"Spanning tree component ready\")\n \n def launch (no_flood = False, hold_down = False):",
      "status": "On branch backport_l2_multi\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   pox/forwarding/l2_multi_new.py\n\tmodified:   pox/lib/packet/lldp.py\n\tmodified:   pox/lib/revent/revent.py\n\tmodified:   pox/openflow/connection_arbiter.py\n\tmodified:   pox/openflow/discovery_new.py\n\tmodified:   pox/openflow/libopenflow_01.py\n\tmodified:   pox/openflow/spanning_tree_new.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    },
    "sts": {
      "branch": "hb",
      "commit": "b4a7dfe4a1043981d3b561176a75d574289d8f36",
      "diff": "diff --git a/config/fuzzer_params.py b/config/fuzzer_params.py\nindex 1807a9a..63b47b4 100644\n--- a/config/fuzzer_params.py\n+++ b/config/fuzzer_params.py\n@@ -11,7 +11,7 @@ link_failure_rate = 0.0\n link_recovery_rate = 1.0\n controller_crash_rate = 0.0\n controller_recovery_rate = 1.0\n-traffic_generation_rate = 0.10\n+traffic_generation_rate = 0.40\n host_migration_rate = 0.0\n intracontroller_block_rate = 0.0\n intracontroller_unblock_rate = 0.0\ndiff --git a/config/trace_floodlight_learningswitch.py b/config/trace_floodlight_learningswitch.py\nindex 9e7537a..dc020c8 100644\n--- a/config/trace_floodlight_learningswitch.py\n+++ b/config/trace_floodlight_learningswitch.py\n@@ -12,7 +12,7 @@ start_cmd = ('''java -ea -Dlogback.configurationFile=./src/main/resources/logbac\n              '''./target/floodlight.jar '''\n               '''-cf ./src/main/resources/trace_learningswitch.properties''')\n \n-controllers = [ControllerConfig(start_cmd, cwd='../floodlight', address=\"127.0.0.1\", port=6633)]\n+controllers = [ControllerConfig(start_cmd, cwd='../floodlight', address=\"127.0.0.1\", port=6633, controller_type='dummy')]\n \n # Uncomment this if you are running Floodlight separately, e.g. for debugging in Eclipse. There must be a controller listening on port 6633.\n # start_cmd = '''echo \"no-op\"'''\ndiff --git a/config/trace_pox_l2_consistency.py b/config/trace_pox_l2_consistency.py\nindex 7a79711..3dd18ed 100644\n--- a/config/trace_pox_l2_consistency.py\n+++ b/config/trace_pox_l2_consistency.py\n@@ -14,9 +14,9 @@ barriers= True\n \n # Use POX as our controller\n start_cmd = ('''./pox.py --verbose '''\n-             ''' forwarding.consistency --consistent=%s --deny=True '''\n+             ''' forwarding.consistency --consistent=%s --deny=False '''\n              ''' --update_wait=10 --update_once=False --consistent_wait=10 --barriers=%s '''\n-             ''' --in_flight_wait=5 --slow_update_wait=10 --update_wait=20 '''\n+             ''' --in_flight_wait=5 --slow_update_wait=10 --update_wait=10 '''\n              ''' openflow.of_01 --address=__address__ --port=__port__ ''' % (consistent, barriers))\n \n controllers = [ControllerConfig(start_cmd, cwd=\"pox/\")]\ndiff --git a/config/trace_pox_l2_multi.py b/config/trace_pox_l2_multi.py\nindex a935594..2b148c1 100644\n--- a/config/trace_pox_l2_multi.py\n+++ b/config/trace_pox_l2_multi.py\n@@ -19,17 +19,17 @@ start_cmd = ('''./pox.py --verbose '''\n \n controllers = [ControllerConfig(start_cmd, cwd=\"pox/\")]\n \n-num = 2\n-#topology_class = StarTopology\n-#topology_params = \"num_hosts=%d\" % num\n+num = 4\n+topology_class = StarTopology\n+topology_params = \"num_hosts=%d\" % num\n #topology_class = MeshTopology\n #topology_params = \"num_switches=%d\" % num\n # topology_class = GridTopology\n # topology_params = \"num_rows=3, num_columns=3\"\n-topology_class = BinaryLeafTreeTopology\n-topology_params = \"num_levels=%d\" % num\n+#topology_class = BinaryLeafTreeTopology\n+#topology_params = \"num_levels=%d\" % num\n \n-steps = 100\n+steps = 200\n # Where should the output files be written to\n results_dir = \"traces/trace_pox_l2_multi-%s%d-steps%s\" % (topology_class.__name__, num, steps)\n \ndiff --git a/pox b/pox\nindex ff35fb1..8bb0754 160000\n--- a/pox\n+++ b/pox\n@@ -1 +1 @@\n-Subproject commit ff35fb1f40f8055b757e2a60e49097e5eb751f0b\n+Subproject commit 8bb0754f4b1c1e5eb830ef1e87b2bb4116f76286-dirty",
      "status": "On branch hb\nYour branch is up-to-date with 'origin/hb'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n  (commit or discard the untracked or modified content in submodules)\n\n\tmodified:   config/fuzzer_params.py\n\tmodified:   config/trace_floodlight_learningswitch.py\n\tmodified:   config/trace_pox_l2_consistency.py\n\tmodified:   config/trace_pox_l2_multi.py\n\tmodified:   pox (new commits, modified content)\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tconfig/pox_consistency.py\n\tconfig/trace_pox_l2_multi_new.py\n\tgen.sh~\n\tmultipage.pdf\n\tshort.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "Ubuntu 15.04",
    "uname": "Linux stsdev 3.19.0-26-generic #28-Ubuntu SMP Tue Aug 11 14:16:32 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux"
  },
  "timestamp": "2015_10_28_18_34_41",
  "user": "ahassany"
}
