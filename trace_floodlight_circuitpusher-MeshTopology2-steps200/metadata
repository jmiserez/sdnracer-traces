{
  "additional_metadata": null,
  "argv": [
    "./simulator.py",
    "-L",
    "logging.cfg",
    "-c",
    "config/trace_floodlight_circuitpusher.py"
  ],
  "cwd": "/home/jeremie/mscthesis/jmiserez/sts",
  "host": {
    "cpu_info": "Intel(R) Core(TM) i7-2720QM CPU @ 2.20GHz",
    "free": "total       used       free     shared    buffers     cached\nMem:      16310124   15612972     697152     159804     595540    4639440\n-/+ buffers/cache:   10377992    5932132\nSwap:     16650236     250068   16400168",
    "name": "espresso",
    "num_cores": "8",
    "uptime": "15:20:35 up 6 days,  3:23, 16 users,  load average: 2.26, 1.28, 1.04"
  },
  "modules": {
    "hassel": {
      "branch": "HEAD",
      "commit": "31afb29fa66783f5a66765bc186509b65ffc023e",
      "diff": "",
      "status": "HEAD detached at 31afb29\nnothing to commit, working directory clean"
    },
    "pox": {
      "branch": "hb",
      "commit": "85cf31dba661265ad8d63f79e9f92fb55d12f383",
      "diff": "",
      "status": "On branch hb\nYour branch is up-to-date with 'origin/hb'.\n\nnothing to commit, working directory clean"
    },
    "sts": {
      "branch": "hb",
      "commit": "853dae80bccc118a428b9dd69b401e2a5b6afeb3",
      "diff": "diff --git a/config/application_events.py b/config/application_events.py\nindex a4ad532..dddcec0 100644\n--- a/config/application_events.py\n+++ b/config/application_events.py\n@@ -52,7 +52,7 @@ class ControllerApp(object):\n     pass\n   \n class AppFloodlightCircuitPusher(ControllerApp):\n-  def __init__(self, app_name, cwd, runtime, script, controller):\n+  def __init__(self, app_name, cwd, runtime, script, controller, background_process=False, wait_secs=0):\n     super(AppFloodlightCircuitPusher, self).__init__(app_name)\n     self._ids = itertools.count(0)\n     self.cwd = cwd\n@@ -63,9 +63,18 @@ class AppFloodlightCircuitPusher(ControllerApp):\n     self.pending_install = []\n     self.installed = []\n     self.pending_removal = []\n+    \n+    self.ip_pair_for_id = dict()\n+    self.free_ip_pairs = None\n+    self.circuited_ip_pairs = []\n   \n     self.ids = dict() # ids -> tuples\n     \n+    self.background_process = background_process\n+    \n+    self.wait_secs = wait_secs\n+    self.last_action_time = None\n+    \n     self.reentrantlock = RLock()    \n     popenTerminationPublisher.addListener(PopenTerminationEvent, self._process_terminated)\n     \n@@ -74,6 +83,21 @@ class AppFloodlightCircuitPusher(ControllerApp):\n   def init_clean_up(self):\n     args = cmdline_to_args('/bin/bash -c \"rm -f circuits.json\"')\n     cmd = popen_simple(args, self.cwd)\n+  \n+  def _has_free_ip_pairs(self):\n+    return len(self.free_ip_pairs) > 0\n+  \n+  def _allocate_ip_pair(self, rng, circuit_id):\n+    chosen_pair = rng.choice(self.free_ip_pairs)\n+    self.free_ip_pairs.remove(chosen_pair)\n+    self.circuited_ip_pairs.append(chosen_pair)\n+    self.ip_pair_for_id[circuit_id] = chosen_pair\n+    return chosen_pair\n+    \n+  def _release_ip_pair(self, circuit_id):\n+    chosen_pair = self.ip_pair_for_id[circuit_id]\n+    self.circuited_ip_pairs.remove(chosen_pair)\n+    self.free_ip_pairs.append(chosen_pair)\n     \n   def _process_terminated(self, event):\n     \"\"\"\n@@ -96,6 +120,7 @@ class AppFloodlightCircuitPusher(ControllerApp):\n         if event.return_code == 0:\n           self.pending_removal.remove(circuit_id)\n           del self.ids[circuit_id]\n+          self._release_ip_pair(circuit_id)\n           print \"Removed circuit: \" + str(circuit_id)\n         else:\n           # error\n@@ -104,43 +129,30 @@ class AppFloodlightCircuitPusher(ControllerApp):\n         \n   def _install_circuits(self, fuzzer, num_circuits):\n     with self.reentrantlock:\n-      candidate_ip_pairs = set()\n-      host_pairs = itertools.combinations(fuzzer.simulation.topology.hosts, 2)\n-      for p in host_pairs:\n-        h1 = p[0]\n-        h2 = p[1]\n-        if len(h1.interfaces) > 0 and len(h2.interfaces) > 0:\n-          interface_pairs = itertools.product(h1.interfaces, h2.interfaces)\n-          for i in interface_pairs:\n-            i1 = i[0]\n-            i2 = i[1]\n-            if i1 is not None and hasattr(i1, 'ips') and i2 is not None and hasattr(i2, 'ips') and len(i1.ips) > 0 and len(i2.ips) > 0:\n-              ip_pairs = itertools.product(i1.ips, i2.ips)\n-              for candidate in ip_pairs:\n-                inverse = (candidate[1], candidate[0])\n-                if (candidate not in self.ids.items() and\n-                    inverse not in self.ids.items()):\n-                  candidate_ip_pairs.add(candidate)\n       num_remaining = num_circuits\n-      while len(candidate_ip_pairs) > 0 and num_remaining > 0:\n-        c = fuzzer.random.choice(tuple(candidate_ip_pairs))\n-        candidate_ip_pairs.remove(c)\n+      while self._has_free_ip_pairs() and num_remaining > 0:\n         circuit_id = self._ids.next()\n+        c = self._allocate_ip_pair(fuzzer.random, circuit_id)\n+        print c\n         self.ids[circuit_id] = c\n         \n         args = cmdline_to_args(self.runtime + ' ' + self.script + ' --controller ' + self.controller + \n                                ' --type ip --src ' + str(c[0].toStr()) + ' --dst ' + str(c[1].toStr()) + ' --add --name ' + str(circuit_id))\n-#     args = cmdline_to_args('bash -c \"ls -al; pwd\"')\n-        cmd = popen_background(circuit_id, args, self.cwd)\n-#         event = popen_blocking(circuit_id, args, self.cwd)\n-        print \"Installing circuit in background: \"+str(c[0].toStr()) + \" <-> \" + str(c[1].toStr() + \" (id: \" + str(circuit_id) + \")\")\n-        # we will get notified when it is done\n-        self.pending_install.append(circuit_id)\n+\n+        if self.background_process:\n+          popen_background(circuit_id, args, self.cwd)\n+          print \"Installing circuit in background: \"+str(c[0].toStr()) + \" <-> \" + str(c[1].toStr() + \" (id: \" + str(circuit_id) + \")\")\n+          # we will get notified when it is done\n+          self.pending_install.append(circuit_id)\n+        else:\n+          self.pending_install.append(circuit_id)\n+          print \"Installing circuit (blocking): \"+str(c[0].toStr()) + \" <-> \" + str(c[1].toStr() + \" (id: \" + str(circuit_id) + \")\")\n+          event = popen_blocking(circuit_id, args, self.cwd)\n+          self._process_terminated(event)\n         data = {'action' : 'add', 'args' : args, 'id' : circuit_id}\n         fuzzer._log_input_event(sts.replay_event.AppEvent(self.app_name, data))\n         num_remaining -= 1\n-#         self._process_terminated(event)\n-    \n+          \n   def _remove_circuits(self, fuzzer, num_circuits):\n     with self.reentrantlock:\n       num_remaining = num_circuits\n@@ -149,27 +161,56 @@ class AppFloodlightCircuitPusher(ControllerApp):\n         assert circuit_id not in self.pending_install\n         assert circuit_id not in self.pending_removal\n         assert circuit_id in self.installed\n+        \n         args = cmdline_to_args(self.runtime + ' ' + self.script + ' --controller ' + self.controller + \n                                ' --delete --name ' + str(circuit_id))\n-        cmd = popen_background(circuit_id, args, self.cwd)\n-        print \"Removing circuit in background: \" + str(circuit_id)\n-        # we will get notified when it is done\n-        self.pending_removal.append(circuit_id)\n-        self.installed.remove(circuit_id)\n+        if self.background_process:\n+          cmd = popen_background(circuit_id, args, self.cwd)\n+          print \"Removing circuit in background: \" + str(circuit_id)\n+          # we will get notified when it is done\n+          self.pending_removal.append(circuit_id)\n+          self.installed.remove(circuit_id)\n+        else:\n+          self.pending_removal.append(circuit_id)\n+          self.installed.remove(circuit_id)\n+          print \"Removing circuit (blocking): \" + str(circuit_id)\n+          event = popen_blocking(circuit_id, args, self.cwd)\n+          self._process_terminated(event)\n         data = {'action' : 'del', 'args' : args, 'id' : circuit_id}\n         fuzzer._log_input_event(sts.replay_event.AppEvent(self.app_name, data))\n         num_remaining -= 1\n \n+  def check_app_beginning(self, fuzzer):\n+    self.free_ip_pairs = []\n+    with self.reentrantlock:\n+      host_pairs = itertools.combinations(fuzzer.simulation.topology.hosts, 2)\n+      for p in host_pairs:\n+        h1 = p[0]\n+        h2 = p[1]\n+        if len(h1.interfaces) > 0 and len(h2.interfaces) > 0:\n+          interface_pairs = itertools.product(h1.interfaces, h2.interfaces)\n+          for i in interface_pairs:\n+            i1 = i[0]\n+            i2 = i[1]\n+            if i1 is not None and hasattr(i1, 'ips') and i2 is not None and hasattr(i2, 'ips') and len(i1.ips) > 0 and len(i2.ips) > 0:\n+              ip_pairs = itertools.product(i1.ips, i2.ips)\n+              for candidate in ip_pairs:\n+                self.free_ip_pairs.append(candidate)\n+    print self.free_ip_pairs\n+\n   def check_app_before(self, fuzzer):\n     pass\n   \n   def check_app_after(self, fuzzer):\n-    if fuzzer.random.random() < fuzzer.params.app_floodlight_circuitpusher_add_rate:\n-      # try to add circuits\n-      self._install_circuits(fuzzer, fuzzer.params.app_floodlight_circuitpusher_add_parallelism)\n-    if fuzzer.random.random() < fuzzer.params.app_floodlight_circuitpusher_del_rate:\n-      # try to delete circuits\n-      self._remove_circuits(fuzzer, fuzzer.params.app_floodlight_circuitpusher_del_parallelism)\n+    now = time.time()\n+    if self.last_action_time is None or (now - self.last_action_time) >= self.wait_secs:\n+      self.last_action_time = now\n+      if fuzzer.random.random() < fuzzer.params.app_floodlight_circuitpusher_add_rate:\n+        # try to add circuits\n+        self._install_circuits(fuzzer, fuzzer.params.app_floodlight_circuitpusher_add_parallelism)\n+      if fuzzer.random.random() < fuzzer.params.app_floodlight_circuitpusher_del_rate:\n+        # try to delete circuits\n+        self._remove_circuits(fuzzer, fuzzer.params.app_floodlight_circuitpusher_del_parallelism)\n   \n   def proceed(self, event, simulation):\n     # TODO(jm): integrate with Replayer. At the moment far this function is never called.\ndiff --git a/config/fuzzer_params.py b/config/fuzzer_params.py\nindex 754fab8..ef07fd2 100644\n--- a/config/fuzzer_params.py\n+++ b/config/fuzzer_params.py\n@@ -17,9 +17,9 @@ intracontroller_block_rate = 0.0\n intracontroller_unblock_rate = 0.0\n vip_ip_list = []\n vip_traffic_percentage = 1.0\n-app_floodlight_circuitpusher_add_rate = 0.5\n+app_floodlight_circuitpusher_add_rate = 1\n app_floodlight_circuitpusher_add_parallelism = 1\n-app_floodlight_circuitpusher_del_rate = 0.1\n+app_floodlight_circuitpusher_del_rate = 0.5\n app_floodlight_circuitpusher_del_parallelism = 1\n app_floodlight_firewall_allow_percentage = 0.8\n app_floodlight_load_balancer_pool_size = 2\n\\ No newline at end of file\ndiff --git a/config/trace_floodlight_circuitpusher.py b/config/trace_floodlight_circuitpusher.py\nindex cbdb5be..a7ed8b1 100644\n--- a/config/trace_floodlight_circuitpusher.py\n+++ b/config/trace_floodlight_circuitpusher.py\n@@ -21,17 +21,17 @@ controllers = [ControllerConfig(start_cmd, cwd='../floodlight', address=\"127.0.0\n num = 2\n # topology_class = StarTopology\n # topology_params = \"num_hosts=%d\" % num\n-#topology_class = MeshTopology\n-#topology_params = \"num_switches=%d\" % num\n+topology_class = MeshTopology\n+topology_params = \"num_switches=%d\" % num\n # topology_class = GridTopology\n # topology_params = \"num_rows=3, num_columns=3\"\n-topology_class = BinaryLeafTreeTopology\n-topology_params = \"num_levels=%d\" % num\n+# topology_class = BinaryLeafTreeTopology\n+# topology_params = \"num_levels=%d\" % num\n \n steps = 200\n-results_dir = \"traces/trace_floodlight_circuitpusher-%s%d-steps%s\" % (topology_class.__name__, num, steps)\n+results_dir = \"paper/trace_floodlight_circuitpusher-%s%d-steps%s\" % (topology_class.__name__, num, steps)\n \n-apps = [AppFloodlightCircuitPusher('circuitpusher', cwd='../floodlight/apps/circuitpusher', runtime='python', script='circuitpusher.py', controller='localhost:8080')]\n+apps = [AppFloodlightCircuitPusher('circuitpusher', background_process=True, wait_secs=1, cwd='../floodlight/apps/circuitpusher', runtime='python', script='circuitpusher.py', controller='localhost:8080')]\n \n simulation_config = SimulationConfig(controller_configs=controllers,\n                                      topology_class=topology_class,\ndiff --git a/config/trace_floodlight_loadbalancer.py b/config/trace_floodlight_loadbalancer.py\nindex 3be7790..ecacb7f 100644\n--- a/config/trace_floodlight_loadbalancer.py\n+++ b/config/trace_floodlight_loadbalancer.py\n@@ -8,7 +8,7 @@ from sts.simulation_state import SimulationConfig\n from sts.happensbefore.hb_logger import HappensBeforeLogger\n from config.application_events import AppFloodlightLoadBalancer\n \n-start_cmd = ('''java -ea -Dlogback.configurationFile=./src/main/resources/logback-trace.xml -jar '''\n+start_cmd = ('''java -ea -Dlogback.configurationFile=./src/main/resources/logback-test-trace.xml -jar '''\n              '''./target/floodlight.jar '''\n               '''-cf ./src/main/resources/trace_loadbalancer.properties''')\n \ndiff --git a/dbglatesttrace.sh b/dbglatesttrace.sh\nindex 0b1ab10..b1a7508 100755\n--- a/dbglatesttrace.sh\n+++ b/dbglatesttrace.sh\n@@ -2,7 +2,7 @@\n \n function mytracefun() {\n   #TRACEDIR=`ls -td -- */ | head -n 1 | cut -d'/' -f1`\n-  TRACEDIR=`ls -td -- traces/* | head -n 1 | cut -d'/' -f1,2`\n+  TRACEDIR=`ls -td -- */* | head -n 1 | cut -d'/' -f1,2`\n   echo \"Latest trace directory (last modified): $TRACEDIR\"\n   echo -n \"hb.json lines: \"\n   cat $TRACEDIR/hb.json | wc -l\n@@ -16,6 +16,24 @@ function mytracefun() {\n   cat $TRACEDIR/simulator.out | grep -i -c error\n   echo -n \"simulator.out # of: assertion \"\n   cat $TRACEDIR/simulator.out | grep -i -c assertion\n+  echo -n \"simulator.out # of: OFPP_TABLE \"\n+  cat $TRACEDIR/simulator.out | grep -i -c OFPP_TABLE\n+  echo -n \"simulator.out # of: \\\"out_port is OFPP_TABLE, but no entry was found\\\" \"\n+  cat $TRACEDIR/simulator.out | grep -i -c \"out_port is OFPP_TABLE, but no entry was found\"\n+  echo -n \"simulator.out # of: ECHO_REQUEST \"\n+  cat $TRACEDIR/simulator.out | grep -i -c ECHO_REQUEST\n+  echo -n \"simulator.out # of: ECHO_REPLY \"\n+  cat $TRACEDIR/simulator.out | grep -i -c ECHO_REPLY\n+  echo -n \"simulator.out # of: \\\"Both source and destination are on the same\\\" \"\n+  cat $TRACEDIR/simulator.out | grep -i -c \"Both source and destination are on the same\"\n+  echo -n \"simulator.out # of: \\\"Removed circuit\\\" \"\n+  cat $TRACEDIR/simulator.out | grep -i -c \"Removed circuit\"\n+  echo -n \"simulator.out # of: \\\"Installed circuit\\\" \"\n+  cat $TRACEDIR/simulator.out | grep -i -c \"Installed circuit\"\n+  echo -n \"simulator.out # of: \\\"Removing circuit\\\" \"\n+  cat $TRACEDIR/simulator.out | grep -i -c \"Removing circuit\"\n+  echo -n \"simulator.out # of: \\\"Installing circuit\\\" \"\n+  cat $TRACEDIR/simulator.out | grep -i -c \"Installing circuit\"\n }\n export -f mytracefun\n watch -n 1 bash -c \"mytracefun\"\ndiff --git a/sts/entities/sts_entities.py b/sts/entities/sts_entities.py\nindex 1a75877..1966c53 100644\n--- a/sts/entities/sts_entities.py\n+++ b/sts/entities/sts_entities.py\n@@ -335,11 +335,11 @@ class TracingNXSoftwareSwitch(NXSoftwareSwitch, EventMixin):\n       # between switch<->controller\n       # Note that this isn't infinite recursion, since the table entry's\n       # out_port will not be OFPP_TABLE\n-      self.process_packet_internally(packet, in_port)\n+      self.process_packet_internally(packet, in_port, cause_is_ofpp_table=True)\n     else:\n       raise RuntimeError(\"Unsupported virtual output port: %x\" % out_port)\n   \n-  def process_packet_internally(self, packet, in_port):\n+  def process_packet_internally(self, packet, in_port, cause_is_ofpp_table=False):\n     assert_type(\"packet\", packet, ethernet, none_ok=False)\n     assert_type(\"in_port\", in_port, int, none_ok=False)\n     \n@@ -352,6 +352,8 @@ class TracingNXSoftwareSwitch(NXSoftwareSwitch, EventMixin):\n       entry.touch_packet(plen, now)\n       self._process_actions_for_packet(entry.actions, packet, in_port)\n     else:\n+      if cause_is_ofpp_table:\n+        self.log.warn(\"Switch-controller recursion: out_port is OFPP_TABLE, but no entry was found and packet is going back to switch as packet in.\")\n       # no matching entry\n       self.raiseEvent(TraceSwitchFlowTableRead(self.dpid, packet, in_port, self.table, None, None, None))\n       buffer_id = self._buffer_packet(packet, in_port)",
      "status": "On branch hb\nYour branch is up-to-date with 'origin/hb'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   config/application_events.py\n\tmodified:   config/fuzzer_params.py\n\tmodified:   config/trace_floodlight_circuitpusher.py\n\tmodified:   config/trace_floodlight_loadbalancer.py\n\tmodified:   dbglatesttrace.sh\n\tmodified:   sts/entities/sts_entities.py\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tall_traces_add_outputs_to_git.sh~\n\tfw2test.sh\n\tfwtest.sh\n\tgen.sh~\n\tlbtest.sh\n\tpaper/\n\txtraces/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "Ubuntu 14.04.3 LTS",
    "uname": "Linux espresso 3.13.0-67-generic #110-Ubuntu SMP Fri Oct 23 13:24:41 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux"
  },
  "timestamp": "2015_11_16_15_20_35",
  "user": "jeremie"
}
