{
  "additional_metadata": null,
  "argv": [
    "./simulator.py",
    "-c",
    "config/trace_pox_l2_consistency.py"
  ],
  "cwd": "/home/ahassany/repos/jsts",
  "host": {
    "cpu_info": "Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz",
    "free": "total       used       free     shared    buffers     cached\nMem:       4045244     286788    3758456       5664      23120     164872\n-/+ buffers/cache:      98796    3946448\nSwap:      4192252          0    4192252",
    "name": "stsdev",
    "num_cores": "2",
    "uptime": "21:36:44 up 18:40,  1 user,  load average: 0.00, 0.02, 0.05"
  },
  "modules": {
    "hassel": {
      "branch": "HEAD",
      "commit": "31afb29fa66783f5a66765bc186509b65ffc023e",
      "diff": "",
      "status": "HEAD detached at 31afb29\nnothing to commit, working directory clean"
    },
    "pox": {
      "branch": "hb",
      "commit": "1ce3d8777c2a1bbaea68c4727a6f1ff59fe7a5d9",
      "diff": "diff --git a/pox/forwarding/consistency.py b/pox/forwarding/consistency.py\nindex 24be0cb..8fd3110 100644\n--- a/pox/forwarding/consistency.py\n+++ b/pox/forwarding/consistency.py\n@@ -501,6 +501,9 @@ class Main(EventMixin):\n     #self.handlers[f2].redirect_serivce(host_ips[service1], fs_ports[monitor])\n     # 4- Update I to forward G traffic to F2, while continuing to\n     #    forward U traffic to F1 and S and F traffic to F3.\n+    self.log.info(\"Sleeping for %d secs\", self.consistent_sleep)\n+    time.sleep(5)\n+    self.log.info(\"Woke up after %d secs\", self.consistent_sleep)\n     self.handlers[internal].redirect_traffic(guest, internal_ports[f2])\n \n   def update_version(self):\ndiff --git a/pox/forwarding/l2_fwd.py b/pox/forwarding/l2_fwd.py\nindex 7b5e12f..27fa175 100644\n--- a/pox/forwarding/l2_fwd.py\n+++ b/pox/forwarding/l2_fwd.py\n@@ -261,6 +261,7 @@ class S2(EventMixin):\n       self.inconsistent_PacketIn(event)\n \n   def _handle_BarrierIn(self, event):\n+    raise RuntimeError()\n     self.log.info(\"BARRIER REPLY%s\", event.xid)\n     t = (self.dpid, event.xid)\n     if t in waiting_msgs:\n@@ -282,6 +283,10 @@ class Main(EventMixin):\n     self.consistent = consistent\n     self.use_barrier = use_barrier\n \n+    print \"CORE\", core\n+    print \"DIR core\", dir(core)\n+    print \"EVENT HANDLERS\", core._eventMixin_handlers\n+\n   def _handle_ConnectionUp (self, event):\n     log.debug(\"Connection %s\", event.connection)\n     dpid = dpidToStr(event.dpid)\n@@ -294,6 +299,10 @@ class Main(EventMixin):\n       self.handlers[s1].s2_conn = self.handlers[s2].s2_conn\n       self.handlers[s2].s1_conn = self.handlers[s1].s1_conn\n \n+    print \"CORE\", core\n+    print \"DIR core\", dir(core)\n+    print \"EVENT HANDLERS\", core._eventMixin_handlers\n+\n \n def launch(consistent=False, use_barrier=True):\n   core.registerNew(Main, consistent=str_to_bool(consistent),",
      "status": "On branch hb\nYour branch is up-to-date with 'origin/hb'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   pox/forwarding/consistency.py\n\tmodified:   pox/forwarding/l2_fwd.py\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tpox/forwarding/l2_multi_new.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    },
    "sts": {
      "branch": "hb",
      "commit": "f7cc0b2d87d3fbc3c57e6ba5cbd22c6953e2f8cf",
      "diff": "diff --git a/config/fuzzer_params.py b/config/fuzzer_params.py\nindex 1807a9a..e8b90ff 100644\n--- a/config/fuzzer_params.py\n+++ b/config/fuzzer_params.py\n@@ -11,7 +11,7 @@ link_failure_rate = 0.0\n link_recovery_rate = 1.0\n controller_crash_rate = 0.0\n controller_recovery_rate = 1.0\n-traffic_generation_rate = 0.10\n+traffic_generation_rate = 0.35\n host_migration_rate = 0.0\n intracontroller_block_rate = 0.0\n intracontroller_unblock_rate = 0.0\ndiff --git a/config/trace_floodlight_hb_learningswitch.py b/config/trace_floodlight_hb_learningswitch.py\nindex 16a1850..c069e84 100644\n--- a/config/trace_floodlight_hb_learningswitch.py\n+++ b/config/trace_floodlight_hb_learningswitch.py\n@@ -12,12 +12,12 @@ from config.application_events import AppCircuitPusher\n \n start_cmd = ('''java -ea -Dlogback.configurationFile=./src/main/resources/logback-trace.xml -jar '''\n              '''./target/floodlight.jar '''\n-              '''-cf ./src/main/resources/hb_learningswitch.properties''')\n+              '''-cf ./src/main/resources/learningswitch.properties''')\n \n # Uncomment this if you are running Floodlight separately, e.g. for debugging in Eclipse. There must be a controller listening on port 6633.\n-# start_cmd = '''echo \"no-op\"'''\n+start_cmd = '''echo \"no-op\"'''\n \n-controllers = [ControllerConfig(start_cmd, cwd='../floodlight', address=\"127.0.0.1\", port=6633)]\n+controllers = [ControllerConfig(start_cmd, cwd='../jfloodlight', address=\"192.168.56.1\", port=6633, controller_type='dummy')]\n \n \n \ndiff --git a/config/trace_pox_l2_consistency.py b/config/trace_pox_l2_consistency.py\nindex 4369691..8b7b2cd 100644\n--- a/config/trace_pox_l2_consistency.py\n+++ b/config/trace_pox_l2_consistency.py\n@@ -10,7 +10,7 @@ from sts.happensbefore.hb_logger import HappensBeforeLogger\n \n \n consistent = True\n-barriers= True\n+barriers= False\n \n # Use POX as our controller\n start_cmd = ('''./pox.py --verbose '''\ndiff --git a/pox b/pox\nindex 3f11583..1ce3d87 160000\n--- a/pox\n+++ b/pox\n@@ -1 +1 @@\n-Subproject commit 3f1158333a8ada3d3d310fb2cb1150caf011021a\n+Subproject commit 1ce3d8777c2a1bbaea68c4727a6f1ff59fe7a5d9-dirty\ndiff --git a/sts/happensbefore/hb_graph.py b/sts/happensbefore/hb_graph.py\nindex 34f5f0f..11e8bf6 100755\n--- a/sts/happensbefore/hb_graph.py\n+++ b/sts/happensbefore/hb_graph.py\n@@ -802,17 +802,11 @@ class HappensBeforeGraph(object):\n     Finds all the races related each packet trace\n     \"\"\"\n     races = []\n-    just_first = False\n     for trace in self.packet_traces:\n       tmp = self.get_racing_events(trace, True)\n       if not tmp:\n         continue\n-      if len(tmp) == 1:\n-        send = trace.graph['host_send']\n-        if trace.has_edge(send.eid, tmp[0].i_event.eid) or\\\n-          trace.has_edge(send.eid, tmp[0].k_event.eid):\n-          just_first = True\n-      races.append((trace, tmp, just_first))\n+      races.append((trace, tmp,))\n     return races\n \n   def summarize_per_packet_inconsistent(self, traces_races, add_just_first=True):\n@@ -878,6 +872,61 @@ class HappensBeforeGraph(object):\n     print \"Saving all races graph in\", name\n     nx.write_dot(graph, os.path.join(self.results_dir, name))\n \n+  def check_covered(self, ordered_trace_events, races):\n+    # Cannot be covered if there is only one race\n+    if len(races) <= 1:\n+      return False\n+\n+    # Collect reads and writes\n+    by_writes = {}\n+    by_reads = {}\n+    for race in races:\n+      if isinstance(race.i_op, TraceSwitchFlowTableWrite):\n+        wr = race.i_event.eid\n+        rd = race.k_event.eid\n+      else:\n+        rd = race.i_event.eid\n+        wr = race.k_event.eid\n+      if wr not in by_writes:\n+        by_writes[wr] = []\n+      if rd not in by_reads:\n+        by_reads[rd] = []\n+      by_writes[wr].append(rd)\n+      by_reads[rd].append(wr)\n+\n+    ordered_racing_reads = []\n+    for eid in ordered_trace_events:\n+      if eid in by_reads:\n+        ordered_racing_reads.append(eid)\n+\n+    # Try to find if the two writes have HB relations between them\n+    found_paths = []\n+    print \"FOUND By REads\",by_reads\n+    for i in range(1, len(ordered_racing_reads)):\n+      r1 = ordered_racing_reads[i-1]\n+      r2 = ordered_racing_reads[i]\n+\n+      for wr1 in by_reads[r1]:\n+        for wr2 in by_reads[r2]:\n+          print \"CHECKING PATH\", wr1, wr2\n+          print \"\\t\", self.g.node[wr1]['event'].operations\n+          print \"\\t\", self.g.node[wr2]['event'].operations\n+          if not nx.has_path(self.g, wr2, wr1):\n+            found_paths.append((wr2, wr1))\n+    for wr2, wr1 in found_paths:\n+      write1 = self.g.node[wr1]['event']\n+      write2 = self.g.node[wr2]['event']\n+      delta = write1.operations[0].t - write2.operations[0].t\n+      print \"T1\", write1.eid, write1, write1.operations[0].t\n+      print \"T2\", write2.eid, write2, write2.operations[0].t\n+      print \"DELTA\", delta\n+      if self.race_detector.add_hb_time and delta >= self.race_detector.ww_delta:\n+        print \"Covered because of time\"\n+        continue\n+      # Now match the tables and check the network forwarding behaviour before w1\n+      return False\n+    return True\n+\n   def find_per_packet_inconsistent(self, ignore_first=False, summarize=True):\n     \"\"\"\n     Returns 3 sets of packet traces. 1) all per-packet inconsistent traces\n@@ -888,6 +937,67 @@ class HappensBeforeGraph(object):\n     :return:\n     \"\"\"\n     packet_races = self.get_all_packet_traces_with_races()\n+\n+\n+    versions_by_dpid = {}\n+    for version, cmds in self.versions.iteritems():\n+      versions_by_dpid[version] = set([getattr(self.g.node[cmd]['event'], 'dpid', None) for cmd in cmds])\n+\n+    print \"versions_by_dpid\", versions_by_dpid\n+    inconsistent_packet_traces = []\n+    inconsistent_packet_entry_version = []\n+\n+    for trace, races in packet_races:\n+      print \"%s->%s\" % (trace.graph['host_send'].packet.src, trace.graph['host_send'].packet.dst)\n+      # Then for sure this is a true inconsistent packet\n+      if len(races) > 1:\n+        racing_versions = []\n+        for race in races:\n+          for version, cmds in self.versions.iteritems():\n+            if race.i_event.eid in cmds or race.k_event.eid in cmds:\n+              racing_versions.append(version)\n+        inconsistent_packet_traces.append((trace, races, list(set(racing_versions))))\n+        #self.check_covered(trace, races)\n+        print \"\\t more than one race\", racing_versions, races\n+        continue\n+      race = races[0]\n+      trace_nodes = nx.dfs_preorder_nodes(trace, trace.graph['host_send'].eid)\n+      trace_dpids = [getattr(self.g.node[node]['event'], 'dpid', None) for node in trace_nodes]\n+      print \"\\ttrace_dpids\", trace_dpids\n+      print \"\\ttrace\", trace_dpids\n+      racing_dpid = race.i_event.dpid\n+      none_racing_dpids = trace_dpids[:trace_dpids.index(racing_dpid)]\n+      print \"\\tRACE DPID\", racing_dpid\n+      print \"\\tNone racing\", none_racing_dpids\n+      racing_version = None\n+      racing_versions = []\n+      for version, cmds in self.versions.iteritems():\n+        if race.i_event.eid in cmds or race.k_event.eid in cmds:\n+          racing_version = version\n+          racing_versions.append(racing_version)\n+      print \"\\tmy version\", racing_version, versions_by_dpid[racing_version]\n+      if versions_by_dpid[racing_version].intersection(none_racing_dpids):\n+        inconsistent_packet_traces.append((trace, races, racing_versions))\n+        print \"INC\",  versions_by_dpid[racing_version].intersection(none_racing_dpids)\n+      else:\n+        inconsistent_packet_entry_version.append((trace, races, version))\n+        print \"VER\",  versions_by_dpid[racing_version]\n+\n+    print \"Inconsistent\", inconsistent_packet_traces\n+    print \"XXXX\"\n+    print \"VERSION\", inconsistent_packet_entry_version\n+\n+\n+    for trace, races, versions in inconsistent_packet_traces:\n+      ordered = list(nx.dfs_preorder_nodes(trace, trace.graph['host_send'].eid))\n+      if self.check_covered(ordered, races):\n+        self.print_racing_packet_trace(trace, races, False, label=\"covered\")\n+      else:\n+        self.print_racing_packet_trace(trace, races, False, label=\"INC\")\n+    for trace, races, versions in inconsistent_packet_entry_version:\n+      self.print_racing_packet_trace(trace, races, False, label=\"VER\")\n+    return [], [], []\n+\n     inconsistent_packet_traces = []\n     ignored_packet_traces = []\n \n@@ -1085,7 +1195,7 @@ class HappensBeforeGraph(object):\n       if isinstance(v, HbMessageSend):\n         print \"React to Msg: \", v.msg_type_str\n       for cmd in cmds:\n-        node =  self.graph.g.node[cmd]['event']\n+        node =  self.g.node[cmd]['event']\n         match = ''\n         if getattr(node.msg, 'match', None):\n           match = node.msg.show().replace('\\n', ' ')\n@@ -1098,6 +1208,34 @@ class HappensBeforeGraph(object):\n           getattr(node.msg, 'actions', None)\n \n \n+  def build_barries_graph(self):\n+    barrier_replies = {}\n+    barrier_replies_by_xid = {} # xid-> reply event\n+    barries_requests_by_xid = {} # xid -> request event\n+    for rep, cmds in self.find_barrier_replies():\n+      print \"REP\", rep\n+      print \"\\tCMDS\", cmds\n+      barrier_replies_by_xid[(rep.dpid, rep.msg.xid)] = rep\n+      barrier_replies[rep.eid] = cmds\n+    for eid, event in self.msg_handles.iteritems():\n+      if event.msg_type_str != 'OFPT_BARRIER_REQUEST':\n+        continue\n+      barries_requests_by_xid[(event.dpid, event.msg.xid)] = event\n+    graph = nx.DiGraph()\n+    for rep, cmds in barrier_replies.iteritems():\n+      graph.add_node(rep, event=self.g.node[rep]['event'])\n+      for cmd in cmds:\n+        graph.add_node(cmd.eid, event=cmd)\n+        graph.add_edge(rep, cmd.eid, rel='mid')\n+    for key, req in barries_requests_by_xid.iteritems():\n+      graph.add_node(req.eid, event=req)\n+      if key in barrier_replies_by_xid:\n+        graph.add_edge(req.eid, barrier_replies_by_xid[key].eid, rel='reply')\n+\n+    self.prep_draw(graph, True)\n+    nx.write_dot(graph, \"/tmp/zig.dot\")\n+\n+\n class Main(object):\n   \n   def __init__(self, filename, print_pkt, print_only_racing, print_only_harmful,\n@@ -1141,13 +1279,16 @@ class Main(object):\n     packet_traces = self.graph.extract_traces(self.graph.g)\n     t3 = time.time()\n \n-    inconsistent_packet_traces, ignored_packet_traces, summarized = self.graph.find_per_packet_inconsistent(self.ignore_first, True)\n+    reactive_cmds = self.graph.find_reactive_versions()\n     t4 = time.time()\n \n-    reactive_cmds = self.graph.find_reactive_versions()\n+    proactive_cmds = self.graph.find_proactive_cmds(reactive_cmds)\n+    versions = self.graph.find_versions()\n     t5 = time.time()\n \n-    proactive_cmds = self.graph.find_proactive_cmds(reactive_cmds)\n+    #self.graph.build_barries_graph()\n+    #return\n+    inconsistent_packet_traces, ignored_packet_traces, summarized = self.graph.find_per_packet_inconsistent(self.ignore_first, True)\n     t6 = time.time()\n \n     racing_versions = self.graph.find_inconsistent_updates()\n@@ -1168,7 +1309,7 @@ class Main(object):\n       self.graph.print_racing_packet_trace(*data, label='ignored')\n     self.graph.save_races_graph(self.print_pkt)\n \n-    versions = self.graph.find_versions()\n+\n     self.graph.print_versions(versions)\n \n     print \"Number of packet inconsistencies: \", len(inconsistent_packet_traces)\n@@ -1179,9 +1320,9 @@ class Main(object):\n     load_time = t1 - t0\n     detect_races_time = t2 - t1\n     extract_traces_time = t3 - t2\n-    per_packet_inconsistent_time = t4 - t3\n-    find_reactive_cmds_time = t5 - t4\n-    find_proactive_cmds_time = t6 - t5\n+    find_reactive_cmds_time = t4 - t3\n+    find_proactive_cmds_time = t5 - t4\n+    per_packet_inconsistent_time = t6 - t5\n     find_inconsistent_update_time = t7 - t6",
      "status": "On branch hb\nYour branch is up-to-date with 'origin/hb'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n  (commit or discard the untracked or modified content in submodules)\n\n\tmodified:   config/fuzzer_params.py\n\tmodified:   config/trace_floodlight_hb_learningswitch.py\n\tmodified:   config/trace_pox_l2_consistency.py\n\tmodified:   pox (new commits, modified content, untracked content)\n\tmodified:   sts/happensbefore/hb_graph.py\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tconfig/pox_consistency.py\n\tconfig/trace_onos_hb_learningswitch.py\n\tgen.sh~\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "Ubuntu 15.04",
    "uname": "Linux stsdev 3.19.0-26-generic #28-Ubuntu SMP Tue Aug 11 14:16:32 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux"
  },
  "timestamp": "2015_09_21_21_36_44",
  "user": "ahassany"
}
