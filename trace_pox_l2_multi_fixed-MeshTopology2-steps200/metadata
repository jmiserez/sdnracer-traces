{
  "additional_metadata": null,
  "argv": [
    "./simulator.py",
    "-c",
    "config/trace_pox_l2_multi_new.py"
  ],
  "cwd": "/home/ahassany/repos/jsts",
  "host": {
    "cpu_info": "Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz",
    "free": "total       used       free     shared    buffers     cached\nMem:       4045244     245244    3800000       5664      19484     126668\n-/+ buffers/cache:      99092    3946152\nSwap:      4192252          0    4192252",
    "name": "stsdev",
    "num_cores": "2",
    "uptime": "23:07:06 up 15:11,  1 user,  load average: 0.00, 0.01, 0.05"
  },
  "modules": {
    "hassel": {
      "branch": "HEAD",
      "commit": "31afb29fa66783f5a66765bc186509b65ffc023e",
      "diff": "",
      "status": "HEAD detached at 31afb29\nnothing to commit, working directory clean"
    },
    "pox": {
      "branch": "backport_l2_multi",
      "commit": "43004a180ae8610869dab89766fc69b52c1bd90f",
      "diff": "diff --git a/pox/forwarding/l2_multi_new.py b/pox/forwarding/l2_multi_new.py\nindex 020c781..d77d6ee 100644\n--- a/pox/forwarding/l2_multi_new.py\n+++ b/pox/forwarding/l2_multi_new.py\n@@ -59,8 +59,8 @@ waiting_paths = {}\n FLOOD_HOLDDOWN = 5\n \n # Flow timeouts\n-FLOW_IDLE_TIMEOUT = 10\n-FLOW_HARD_TIMEOUT = 30\n+FLOW_IDLE_TIMEOUT = 5\n+FLOW_HARD_TIMEOUT = 5\n \n # How long is allowable to set up a path?\n PATH_SETUP_TIME = 4\n@@ -168,7 +168,7 @@ class WaitingPath (object):\n   \"\"\"\n   A path which is waiting for its path to be established\n   \"\"\"\n-  def __init__ (self, path, packet):\n+  def __init__ (self, path, packet, in_port):\n     \"\"\"\n     xids is a sequence of (dpid,xid)\n     first_switch is the DPID where the packet came from\n@@ -179,6 +179,7 @@ class WaitingPath (object):\n     self.first_switch = path[0][0].dpid\n     self.xids = set()\n     self.packet = packet\n+    self.in_port = in_port\n \n     if len(waiting_paths) > 1000:\n       WaitingPath.expire_waiting_paths()\n@@ -195,26 +196,22 @@ class WaitingPath (object):\n     \"\"\"\n     Called when a barrier has been received\n     \"\"\"\n+    \"\"\"\n+    Called when a barrier has been received\n+    \"\"\"\n     self.xids.discard((event.dpid,event.xid))\n+    log.debug(\"NOTIFY dpid %s, xid %s, xids %s\", event.dpid, event.xid, self.xids)\n     if len(self.xids) == 0:\n       # Done!\n       if self.packet:\n-        log.debug(\"Sending delayed packet out %s\"\n-                  % (dpidToStr(self.first_switch),))\n-        msg = of.ofp_packet_out(data=self.packet)\n-        if self.packet.dst == EthAddr(\"0:00:00:00:00:01\"):\n-          port = 1\n-        else:\n-          port = 2\n-        #msg.actions = [of.ofp_action_output(port=port)]\n-        #msg.actions = [of.ofp_action_output(data=self.packet, port=of.OFPP_TABLE)]\n-        msg = of.ofp_packet_out(data=self.packet,\n+        log.debug(\"Sending delayed packet out at switch %s\",\n+                  (dpidToStr(self.first_switch)))\n+        msg = of.ofp_packet_out(data=self.packet, in_port=self.in_port,\n             action=of.ofp_action_output(port=of.OFPP_TABLE))\n         core.openflow.sendToDPID(self.first_switch, msg)\n \n       core.l2_multi.raiseEvent(PathInstalled(self.path))\n \n-\n   @staticmethod\n   def expire_waiting_paths ():\n     packets = set(waiting_paths.values())\n@@ -251,8 +248,6 @@ class Switch (EventMixin):\n   def _install (self, switch, in_port, out_port, match, buf = NO_BUFFER):\n     #log.info(\"Installing in_port=%d, out_port=%d, type=%s,  match=%s, buf=%s\", in_port, out_port, type(out_port), match, buf)\n     log.info(\"XXX Installing flowmod on sw=%s, in_port=%d, out_port=%d, buf=%s\", dpidToStr(switch.dpid), in_port, out_port,buf)\n-    assert  out_port not in [65535, '65535']\n-    assert int(in_port) != 65535\n     msg = of.ofp_flow_mod()\n     msg.match = match\n     msg.match.in_port = in_port\n@@ -260,20 +255,10 @@ class Switch (EventMixin):\n     msg.hard_timeout = FLOW_HARD_TIMEOUT\n     msg.actions.append(of.ofp_action_output(port = out_port))\n     msg.buffer_id = buf\n-    assert msg.match\n-    assert msg.match.in_port\n-    assert msg.idle_timeout\n-    assert msg.hard_timeout\n-    assert msg.actions\n-    assert msg.buffer_id\n-    #assert msg.cookie\n-    msg.out_port == out_port\n-    assert msg.priority\n-    #log.info(\"Sending msg %s\", msg)\n     switch.connection.send(msg)\n \n-  def _install_path (self, p, match, packet_in=None):\n-    wp = WaitingPath(p, packet_in)\n+  def _install_path (self, p, match, packet_in=None, in_port=None):\n+    wp = WaitingPath(p, packet_in, in_port=in_port)\n     for sw, in_port, out_port in p:\n       #log.info(\"Installing segment on switch: '%s', in_port=%d, outport='%d' and macth='%s'\", sw, in_port, out_port, match)\n       log.info(\"XXX Installing segment on switch: '%s', in_port=%d, outport='%d'\", sw, in_port, out_port)\n@@ -326,26 +311,25 @@ class Switch (EventMixin):\n \n       return\n \n-    log.debug(\"Installing path for %s -> %s %s (%s hops)\",\n-        match.dl_src, match.dl_dst, match.dl_type, len(p))\n+    log.debug(\"Installing path for %s -> %s %s (%s hops) and path is %s\",\n+        match.dl_src, match.dl_dst, match.dl_type, len(p), p)\n \n     # We have a path -- install it\n-    self._install_path(p, match, event.parsed)\n+    self._install_path(p, match, event.parsed, in_port=event.port)\n \n     # Now reverse it and install it backwards\n     # (we'll just assume that will work)\n     p = [(sw,out_port,in_port) for sw,in_port,out_port in p]\n-    self._install_path(p, match.flip())\n+    self._install_path(p, match.flip(), in_port=event.port)\n \n \n   def _handle_PacketIn (self, event):\n-    if event.port == 65535:\n-      log.warn(\"Ignoring event from of.OFPP_TABLE %s\", str(event))\n-      return\n+    packet = event.parsed\n     def flood ():\n       \"\"\" Floods the packet \"\"\"\n       if self.is_holding_down:\n         log.warning(\"Not flooding -- holddown active\")\n+      log.debug(\"Flooding packet src=%s, dst=%s\", packet.src, packet.dst)\n       msg = of.ofp_packet_out()\n       # OFPP_FLOOD is optional; some switches may need OFPP_ALL\n       msg.actions.append(of.ofp_action_output(port = of.OFPP_FLOOD))\n@@ -355,7 +339,9 @@ class Switch (EventMixin):\n \n     def drop ():\n       # Kill the buffer\n+      return\n       if event.ofp.buffer_id is not None:\n+        log.debug(\"Killing packet at buffer src=%s, dst=%s\", packet.src, packet.dst)\n         msg = of.ofp_packet_out()\n         msg.buffer_id = event.ofp.buffer_id\n         event.ofp.buffer_id = None # Mark is dead\n@@ -363,13 +349,13 @@ class Switch (EventMixin):\n         self.connection.send(msg)\n \n     packet = event.parsed\n-    log.info(\"XXXXX PACKET IN: dpid=%s, in_port: %d, src=%s, dst=%s\", dpidToStr(event.dpid), event.port, packet.src, packet.dst)\n+    log.info(\"PACKET IN: dpid=%s, in_port: %d, src=%s, dst=%s, buffer id: %s\", dpidToStr(event.dpid), event.port, packet.src, packet.dst, event.ofp.buffer_id)\n \n-    print \"LOC for\", packet.src, \" is\", event.port\n-    print \"But old is \", mac_map.get(packet.src)\n     loc = (self, event.port) # Place we saw this ethaddr\n     oldloc = mac_map.get(packet.src) # Place we last saw this ethaddr\n \n+    log.debug(\"Packet IN location %s and old location is %s\", loc, oldloc)\n+\n     if packet.type == packet.LLDP_TYPE:\n       drop()\n       return\n@@ -380,7 +366,7 @@ class Switch (EventMixin):\n         log.debug(\"Learned %s at %s.%i\", packet.src, loc[0], loc[1])\n     elif oldloc != loc:\n       # ethaddr seen at different place!\n-      if core.openflow_discovery.is_edge_port(loc[0].dpid, loc[1]):\n+      if core.openflow_discovery_new.is_edge_port(loc[0].dpid, loc[1]):\n         # New place is another \"plain\" port (probably)\n         log.debug(\"%s moved from %s.%i to %s.%i?\", packet.src,\n                   dpidToStr(oldloc[0].dpid), oldloc[1],\n@@ -457,12 +443,18 @@ class l2_multi (EventMixin):\n     # Listen to dependencies\n     def startup ():\n       core.openflow.addListeners(self, priority=0)\n-      core.openflow_discovery.addListeners(self)\n+      core.openflow_discovery_new.addListeners(self)\n     #core.call_when_ready(startup, ('openflow','openflow_discovery'))\n     core.openflow.addListeners(self, priority=0)\n-    core.openflow_discovery.addListeners(self)\n+    core.openflow_discovery_new.addListeners(self, priority=0)\n \n   def _handle_LinkEvent (self, event):\n+    log.info(\"XXXXXXXXXX LinkEvent: %s\", event.link)\n+    for k,v in adjacency.iteritems():\n+      print k, v\n+      for k2, v2 in v.iteritems():\n+        print k2, v2\n+    #print adjacency\n     def flip (link):\n       return Discovery.Link(link[2],link[3], link[0],link[1])\n \n@@ -479,6 +471,7 @@ class l2_multi (EventMixin):\n     clear = of.ofp_flow_mod(command=of.OFPFC_DELETE)\n     for sw in switches.itervalues():\n       if sw.connection is None: continue\n+      log.info(\"XXXX _handle_LinkEvent clear Sending clear to: %s\", sw)\n       sw.connection.send(clear)\n     path_map.clear()\n \n@@ -488,9 +481,9 @@ class l2_multi (EventMixin):\n       if sw1 in adjacency[sw2]: del adjacency[sw2][sw1]\n \n       # But maybe there's another way to connect these...\n-      for ll in core.openflow_discovery.adjacency:\n+      for ll in core.openflow_discovery_new.adjacency:\n         if ll.dpid1 == l.dpid1 and ll.dpid2 == l.dpid2:\n-          if flip(ll) in core.openflow_discovery.adjacency:\n+          if flip(ll) in core.openflow_discovery_new.adjacency:\n             # Yup, link goes both ways\n             adjacency[sw1][sw2] = ll.port1\n             adjacency[sw2][sw1] = ll.port2\n@@ -503,7 +496,7 @@ class l2_multi (EventMixin):\n       if adjacency[sw1][sw2] is None:\n         # These previously weren't connected.  If the link\n         # exists in both directions, we consider them connected now.\n-        if flip(l) in core.openflow_discovery.adjacency:\n+        if flip(l) in core.openflow_discovery_new.adjacency:\n           # Yup, link goes both ways -- connected!\n           adjacency[sw1][sw2] = l.port1\n           adjacency[sw2][sw1] = l.port2\ndiff --git a/pox/lib/packet/lldp.py b/pox/lib/packet/lldp.py\nindex eb628ea..16608e4 100644\n--- a/pox/lib/packet/lldp.py\n+++ b/pox/lib/packet/lldp.py\n@@ -1,20 +1,17 @@\n-# Copyright 2011 James McCauley\n+# Copyright 2012 James McCauley\n # Copyright 2008 (C) Nicira, Inc.\n #\n-# This file is part of POX.\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at:\n #\n-# POX is free software: you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation, either version 3 of the License, or\n-# (at your option) any later version.\n+#     http://www.apache.org/licenses/LICENSE-2.0\n #\n-# POX is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with POX.  If not, see <http://www.gnu.org/licenses/>.\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n \n # This file is derived from the packet library in NOX, which was\n # developed by Nicira, Inc.\n@@ -57,14 +54,13 @@\n # 9-126 - reserved\n #\n # TODO:\n-#   Error handling (malformed packetswill definately cause this to\n-#   puke)\n+# Error handling (malformed packets will definately cause this to puke)\n #\n #======================================================================\n \n import struct\n import time\n-from packet_utils       import *\n+from packet_utils import *\n \n from packet_base import packet_base\n from pox.lib.addresses import EthAddr\n@@ -78,496 +74,470 @@ lg = logging.getLogger('packet')\n #======================================================================\n \n class lldp (packet_base):\n-    \"802.1 AB lldp pdu\"\n+  \"802.1 AB lldp pdu\"\n+\n+  # chassis ID min = 2 + 1 + 1\n+  # PORT    ID min = 2 + 1 + 1\n+  # TTL        min = 2 + 2\n+  # End        min = 2\n+  MIN_LEN = (4 + 4 + 4 + 2 )\n+\n+  #TODO: Remove these from here (they should be at module scope)?\n+  END_TLV         = 0\n+  CHASSIS_ID_TLV  = 1\n+  PORT_ID_TLV     = 2\n+  TTL_TLV         = 3\n+  PORT_DESC_TLV   = 4\n+  SYSTEM_NAME_TLV = 5\n+  SYSTEM_DESC_TLV = 6\n+  SYSTEM_CAP_TLV  = 7\n+  MANAGEMENT_ADDR_TLV = 8\n+  ORGANIZATIONALLY_SPECIFIC_TLV = 127\n+\n+  tlv_parsers = {}\n+\n+  def __init__ (self, raw=None, prev=None, **kw):\n+    packet_base.__init__(self)\n+\n+    self.prev = prev\n+\n+    self.next = None\n+    self.tlvs = []\n+\n+    if raw is not None:\n+      self.parse(raw)\n+\n+    self._init(kw)\n+\n+  def next_tlv(self, array):\n+\n+    if len(array) < 2:\n+      self.msg('(lldp tlv parse) warning TLV data too short to read '\n+               + 'type/len (%u)' % (len(array),))\n+      return\n+\n+    (typelen,) = struct.unpack(\"!H\",array[0:2])\n+\n+    type = typelen >> 9\n+    length = typelen & 0x01ff\n+\n+    if len(array) < length:\n+      self.msg('(lldp tlv parse) warning TLV data too short to parse (%u)'\n+               % (len(array),))\n+      return\n+\n+    if type in lldp.tlv_parsers:\n+      self.tlvs.append(lldp.tlv_parsers[type](array[0: 2 + length]))\n+      return 2 + length\n+    else:\n+      self.msg('(lldp tlv parse) warning unknown tlv type (%u)'\n+               % (type,))\n+      self.tlvs.append(unknown_tlv(array[0: 2 + length]))\n+      return 2 + length\n+\n+  def parse (self, raw):\n+    assert isinstance(raw, bytes)\n+    self.raw = raw\n+    dlen = len(raw)\n+    if dlen < lldp.MIN_LEN:\n+      self.msg('(lldp parse) warning LLDP packet data too short to parse '\n+               + 'header: data len %u' % (dlen,))\n+      return\n+\n+    # point to the beginning of the pdu\n+    pduhead = 0\n+\n+    # get Chassis ID\n+    ret = self.next_tlv(raw)\n+    if ret == None:\n+      self.msg( '(lldp parse) error parsing chassis ID tlv' )\n+      return\n+    pduhead += ret\n+    if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.CHASSIS_ID_TLV:\n+      self.msg( '(lldp parse) error CHASSIS ID TLV missing' )\n+      return\n+\n+    # get PORT ID\n+    ret = self.next_tlv(raw[pduhead:])\n+    if ret is None:\n+      self.msg( '(lldp parse) error parsing port ID TLV' )\n+      return\n+    pduhead += ret\n+    if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.PORT_ID_TLV:\n+      self.msg( '(lldp parse) error port ID TLV missing' )\n+      return\n+\n+    # get  TTL\n+    ret = self.next_tlv(raw[pduhead:])\n+    if ret == None:\n+      self.msg( '(lldp parse) error parsing TTL TLV' )\n+      return\n+    pduhead += ret\n+    if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.TTL_TLV:\n+      self.msg( '(lldp parse) error port TTL TLV missing' )\n+      return\n+\n+    # Loop over all other TLVs\n+    arr_len = len(raw)\n+    while True:\n+      ret = self.next_tlv(raw[pduhead:])\n+      if ret == None:\n+        self.msg( '(lldp parse) error parsing TLV' )\n+        return\n+      if self.tlvs[len(self.tlvs)-1].tlv_type == lldp.END_TLV:\n+        break\n+      if (pduhead + ret) >= arr_len:\n+        self.msg( '(lldp parse) error end of TLV list without END TLV' )\n+        return\n+      pduhead += ret\n+\n+    self.parsed = True\n+\n+  def add_tlv (self, tlv):\n+    self.tlvs.append(tlv)\n+\n+  def __str__ (self):\n+    lstr = ''\n+    for tlv in self.tlvs:\n+      lstr += str(tlv)\n+    return '[LLDP ' + lstr + ']'\n+\n+  def hdr (self, payload):\n+    packet = b''\n+    for tlv in self.tlvs:\n+      packet += tlv.pack()\n+    return packet\n \n-    # chassis ID min = 2 + 1 + 1\n-    # PORT    ID min = 2 + 1 + 1\n-    # TTL        min = 2 + 2\n-    # End        min = 2\n-    MIN_LEN = (4 + 4 + 4 + 2 )\n \n-    #TODO: Remove these from here (they should be at module scope)?\n-    END_TLV         = 0\n-    CHASSIS_ID_TLV  = 1\n-    PORT_ID_TLV     = 2\n-    TTL_TLV         = 3\n-    PORT_DESC_TLV   = 4\n-    SYSTEM_NAME_TLV = 5\n-    SYSTEM_DESC_TLV = 6\n-    SYSTEM_CAP_TLV  = 7\n-    MANAGEMENT_ADDR_TLV = 8\n-    ORGANIZATIONALLY_SPECIFIC_TLV = 127\n+#======================================================================\n+#                          TLV definitions\n+#======================================================================\n \n-    tlv_parsers = {}\n+#NOTE: As with a bunch of the packet library, it'd be nice if things\n+#      like TLVs inherited from some base class common to other\n+#      \"sub-packets\" (and maybe even packets).\n \n-    def __init__(self, raw=None, prev=None, **kw):\n-        packet_base.__init__(self)\n+class tlv_base (object):\n+  \"\"\"\n+  Supertype for LLDP TLVs\n+  \"\"\"\n+  pass\n \n-        self.prev = prev\n \n-        self.next = None\n-        self.tlvs = []\n+class simple_tlv (tlv_base):\n+  tlv_type = None # Purposely illegal\n \n-        if raw is not None:\n-            self.parse(raw)\n+  def __init__ (self, raw = None, **kw):\n+    self._init(kw)\n+    self.parsed   = False\n \n-        self._init(kw)\n+    if raw is not None:\n+      self.parse(raw)\n \n-    def next_tlv(self, array):\n+    self._init_helper(kw)\n \n-        if len(array) < 2:\n-            self.msg('(lldp tlv parse) warning TLV data too short to read type/len (%u)' % (len(array),))\n-            return\n+  def _init_helper (self, kw):\n+    if len(kw):\n+      if 'payload' in kw:\n+        self.payload = None\n+      initHelper(self, kw)\n+      self.parsed = True\n \n-        (typelen,) = struct.unpack(\"!H\",array[0:2])\n+  def parse (self, raw):\n+    # assume lldp has done the type/len checking\n+    (typelen,) = struct.unpack(\"!H\", raw[0:2])\n+    tlv_type = typelen >> 9\n+    if self.tlv_type is not None:\n+      assert self.tlv_type == tlv_type\n+    self.tlv_type = tlv_type\n \n-        type      = typelen >> 9\n-        length    = typelen & 0x01ff\n+    strlen = typelen & 0x01ff\n+\n+    data = raw[2:2+strlen]\n+    if len(data) < strlen:\n+      raise TruncatedException()\n \n-        if len(array) < length:\n-            self.msg( '(lldp tlv parse) warning TLV data too short to parse (%u)' % (len(array),))\n-            return\n+    self._parse_data(data)\n+    self.parsed = True\n \n-        if type in lldp.tlv_parsers:\n-            self.tlvs.append(lldp.tlv_parsers[type](array[0: 2 + length]))\n-            return 2 + length\n-        else:\n-            self.msg( '(lldp tlv parse) warning unknown tlv type (%u)' % (type,) )\n-            # TODO: unknown_tlv is an undefined variable! Check me in?\n-            self.tlvs.append(unknown_tlv(array[0: 2 + length]))\n-            return 2 + length\n-\n-    def parse(self, raw):\n-        assert isinstance(raw, bytes)\n-        self.raw = raw\n-        dlen = len(raw)\n-        if dlen < lldp.MIN_LEN:\n-            self.msg( '(lldp parse) warning LLDP packet data too short to parse header: data len %u' % (dlen,))\n-            return\n-\n-        # point to the beginning of the pdu\n-        pduhead = 0\n-\n-        # get Chassis ID\n-        ret = self.next_tlv(raw)\n-        if ret == None:\n-            self.msg( '(lldp parse) error parsing chassis ID tlv' )\n-            return\n-        pduhead += ret\n-        if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.CHASSIS_ID_TLV:\n-            self.msg( '(lldp parse) error CHASSIS ID TLV missing' )\n-            return\n-\n-        # get PORT ID\n-        ret = self.next_tlv(raw[pduhead:])\n-        if ret is None:\n-            self.msg( '(lldp parse) error parsing port ID TLV' )\n-            return\n-        pduhead += ret\n-        if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.PORT_ID_TLV:\n-            self.msg( '(lldp parse) error port ID TLV missing' )\n-            return\n-\n-        # get  TTL\n-        ret = self.next_tlv(raw[pduhead:])\n-        if ret == None:\n-            self.msg( '(lldp parse) error parsing TTL TLV' )\n-            return\n-        pduhead += ret\n-        if self.tlvs[len(self.tlvs)-1].tlv_type != lldp.TTL_TLV:\n-            self.msg( '(lldp parse) error port TTL TLV missing' )\n-            return\n-\n-        # Loop over all other TLVs\n-        arr_len = len(raw)\n-        while True:\n-            ret = self.next_tlv(raw[pduhead:])\n-            if ret == None:\n-                self.msg( '(lldp parse) error parsing TLV' )\n-                return\n-            if self.tlvs[len(self.tlvs)-1].tlv_type == lldp.END_TLV:\n-                break\n-            if (pduhead + ret) >= arr_len:\n-                self.msg( '(lldp parse) error end of TLV list without END TLV' )\n-                return\n-            pduhead += ret\n-\n-        self.parsed = True\n-\n-    def add_tlv(self, tlv):\n-        self.tlvs.append(tlv)\n-\n-    def __str__(self):\n-        lstr = ''\n-        for tlv in self.tlvs:\n-            lstr += str(tlv)\n-        return lstr\n-\n-    def hdr(self, payload):\n-        packet = b''\n-        for tlv in self.tlvs:\n-            packet += tlv.pack()\n-        return packet\n+  @property\n+  def strlen (self):\n+    return self._data_len()\n \n+  def pack (self):\n+    typelen = self.tlv_type << 9\n+    data = self._pack_data()\n+    typelen |= (len(data) & 0x01ff)\n+    return struct.pack('!H', typelen) + data\n \n-#======================================================================\n-#                          TLV definitions\n-#======================================================================\n-        \n-class chassis_id:\n-    tlv_type = lldp.CHASSIS_ID_TLV\n-\n-    SUB_CHASSIS  = 1 # IETF RFC 2737\n-    SUB_IF_ALIAS = 2 # IETF RFC 2863\n-    SUB_PORT     = 3 # IETF RFC 2737\n-    SUB_MAC      = 4 # IEEE Std 802-2001\n-    SUB_NETWORK  = 5 #\n-    SUB_IF_NAME  = 6 # IETF RFC 2863\n-    SUB_LOCAL    = 7\n-\n-    subtype_to_str = {}\n-    subtype_to_str[SUB_CHASSIS]  = \"chassis\"\n-    subtype_to_str[SUB_IF_ALIAS] = \"interface alias\"\n-    subtype_to_str[SUB_PORT]     = \"port\"\n-    subtype_to_str[SUB_MAC]      = \"mac\"\n-    subtype_to_str[SUB_NETWORK]  = \"network\"\n-    subtype_to_str[SUB_IF_NAME]  = \"interface name\"\n-    subtype_to_str[SUB_LOCAL]    = \"local\"\n-\n-    # Construct from packet data\n-    def __init__(self, raw = None, **kw):\n-        self.parsed   = False\n-        self.strlen   = 0\n-        self.subtype  = 0\n-        self.id       = None\n-        self.arr      = None\n-        if raw is not None:\n-            self.arr = raw\n-            self.parse()\n-        initHelper(self, kw)\n-   \n-    def fill(self, _subtype, strval):\n-        self.strlen  = 1 + len(strval)\n-        self.subtype = _subtype\n-        self.id      = strval\n+  def __str__ (self):\n+    return \"<\" + self.__class__.__name__ + \">\"\n+\n+\n+  def _init (self, kw):\n+    \"\"\"\n+    Initialize subclass-specific fields\n+\n+    Override this.\n+    \"\"\"\n+    pass\n+\n+  def _data_len (self):\n+    \"\"\"\n+    Returns length of the TLV information string\n+\n+    Override this.\n+    \"\"\"\n+    return len(self._pack_data())\n+\n+  def _parse_data (self, data):\n+    \"\"\"\n+    Store TLV information string\n+\n+    Override this.\n+    \"\"\"\n+    self.payload = data\n+\n+  def _pack_data (self):\n+    \"\"\"\n+    Return TLV information string\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-\n-        self.tlv_type = typelen >> 9\n-        assert(self.tlv_type == 1)\n-        self.strlen = typelen & 0x01ff\n-        assert(self.strlen >= 2)\n-        (self.subtype,) = struct.unpack(\"!B\",self.arr[2:3])\n-        self.id = self.arr[3:]\n-        self.parsed = True\n-\n-    def hdr(self, payload):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.strlen & 0x01ff)\n-        pack_str = '!HB'+str(self.strlen-1)+'s'\n-        return struct.pack(pack_str, typelen, self.subtype, self.id)\n-\n-    def pack(self):\n-        packet = self.hdr(0)\n-        return packet\n-\n-    def __str__(self):\n-        if self.subtype == chassis_id.SUB_MAC:\n-            assert len(self.id) == 6\n-            id_str = str(EthAddr(self.id))\n-        else:\n-            id_str = \":\".join([\"%02x\" % (ord(x),) for x in self.id])\n-\n-        return ''.join(['<chasis ID:',id_str,'>'])\n-\n-class port_id:\n-    tlv_type = lldp.PORT_ID_TLV\n-\n-    SUB_IF_ALIAS = 1 # IETF RFC 2863\n-    SUB_PORT     = 2 # IETF RFC 2737\n-    SUB_MAC      = 3 # IEEE Std 802-2001\n-    SUB_NETWORK  = 4 #\n-    SUB_IF_NAME  = 5 # IETF RFC 2863\n-    SUB_CIRC_ID  = 6 # IETF RFC 3046\n-    SUB_LOCAL    = 7\n-\n-    subtype_to_str = {}\n-    subtype_to_str[SUB_IF_ALIAS] = \"interface alias\"\n-    subtype_to_str[SUB_PORT]     = \"port\"\n-    subtype_to_str[SUB_MAC]      = \"mac\"\n-    subtype_to_str[SUB_NETWORK]  = \"network\"\n-    subtype_to_str[SUB_IF_NAME]  = \"interface name\"\n-    subtype_to_str[SUB_CIRC_ID]  = \"agent circuit ID\"\n-    subtype_to_str[SUB_LOCAL]    = \"local\"\n-\n-    def __init__(self, raw = None, **kw):\n-        self.parsed = False\n-        self.subtype = 0\n-        self.id      = None\n-        self.arr     = raw\n-        if raw is not None:\n-            self.parse()\n-\n-    @property\n-    def strlen (self):\n-      return 1 + len(self.id)\n-\n-    def fill(self, subtype, strval):\n-        self.subtype = subtype\n-        self.id      = strval\n+    Override this.\n+    \"\"\"\n+    return self.payload\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-\n-        self.tlv_type = typelen >> 9\n-        assert(self.tlv_type == 2)\n-        strlen = typelen & 0x01ff\n-        assert(strlen >= 2)\n-        (self.subtype,) = struct.unpack(\"!B\",self.arr[2:3])\n-        self.id = self.arr[3:]\n-        assert strlen == 1 + len(self.id)\n-        parsed = True\n-\n-    def __str__(self):\n-        if self.subtype == chassis_id.SUB_MAC:\n-            assert len(self.id) == 6\n-            id_str = str(EthAddr(self.id))\n-        else:\n-            id_str = \":\".join([\"%02x\" % (ord(x),) for x in self.id])\n \n-        return ''.join(['<port ID:',id_str,'>'])\n+class unknown_tlv (simple_tlv):\n+  \"\"\"\n+  Unknown TLVs are parsed into this class\n+  \"\"\"\n+  tlv_type = None\n \n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.strlen & 0x01ff)\n-        pack_str = '!HB'+str(self.strlen-1)+'s'\n-        return struct.pack(pack_str, typelen, self.subtype, self.id)\n \n-class ttl:\n-    tlv_type = lldp.TTL_TLV\n+class chassis_id (simple_tlv):\n+  tlv_type = lldp.CHASSIS_ID_TLV\n \n-    def __init__(self, raw = None, **kw):\n-        self.parsed = False\n-        self.strlen  = 2\n-        self.ttl     = 0\n-        self.arr     = raw\n+  SUB_CHASSIS  = 1 # IETF RFC 2737\n+  SUB_IF_ALIAS = 2 # IETF RFC 2863\n+  SUB_PORT     = 3 # IETF RFC 2737\n+  SUB_MAC      = 4 # IEEE Std 802-2001\n+  SUB_NETWORK  = 5 #\n+  SUB_IF_NAME  = 6 # IETF RFC 2863\n+  SUB_LOCAL    = 7\n \n-        if raw is not None:\n-            self.parse()\n+  subtype_to_str = {}\n+  subtype_to_str[SUB_CHASSIS]  = \"chassis\"\n+  subtype_to_str[SUB_IF_ALIAS] = \"interface alias\"\n+  subtype_to_str[SUB_PORT]     = \"port\"\n+  subtype_to_str[SUB_MAC]      = \"mac\"\n+  subtype_to_str[SUB_NETWORK]  = \"network\"\n+  subtype_to_str[SUB_IF_NAME]  = \"interface name\"\n+  subtype_to_str[SUB_LOCAL]    = \"local\"\n \n-        initHelper(self, kw)\n+  def _init (self, kw):\n+    self.subtype  = 0\n+    self.id       = None\n \n-    def fill(self, ttl):\n-        self.ttl    = ttl\n+  def _parse_data (self, data):\n+    if len(data) < 2:\n+      raise MalformedException(\"TLV has invalid strlen\")\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-\n-        self.tlv_type = typelen >> 9\n-        assert(self.tlv_type == 3)\n-        self.strlen = typelen & 0x01ff\n-        if (self.strlen != 2):\n-            lg.info('(ttl tlv parse) length incorrect (should be 2) %u', self.strlen)\n-            return\n-        (self.ttl,) = struct.unpack(\"!H\",self.arr[2:4])\n-        self.parsed = True\n-\n-    def __str__(self):\n-        return ''.join(['<ttl:',str(self.ttl),'>'])\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.strlen & 0x01ff)\n-        pack_str = '!HB'+str(self.strlen-1)+'s'\n-        return struct.pack('!HH', typelen, self.ttl)\n-\n-class end_tlv:\n-    tlv_type = lldp.END_TLV\n-\n-    def __init__(self, raw = None):\n-        self.parsed = False\n-        self.strlen  = 0\n-        self.arr     = raw \n-        if raw is not None:\n-            self.parse()\n+    (self.subtype,) = struct.unpack(\"!B\",data[0:1])\n+    self.id = data[1:]\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-        self.tlv_type = typelen >> 9\n-        assert(self.tlv_type == lldp.END_TLV)\n-        self.strlen = typelen & 0x01ff\n-        if self.strlen != 0:\n-            lg.info('(tl end parse) length incorrect (should be 0) %u', self.strlen)\n-            return\n-        self.parsed = True\n-\n-    def __str__(self):\n-        return '<tlv end>'\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.strlen & 0x01ff)\n-        return struct.pack('!H', typelen)\n-\n-class basic_tlv (object):\n-    #tlv_type = <type>\n-    def __init__(self, raw = None):\n-        self.parsed = False\n-        self.len    = 0\n-        self.arr    = raw\n-        self.next   = b''\n-        if raw is not None:\n-            self.parse()\n-\n-    def fill(self, strval):\n-        self.len  = len(strval)\n-        self.next = strval\n+  def _pack_data (self):\n+    return struct.pack(\"!B\", self.subtype) + self.id\n \n-    # assume lldp has done the type/len checking\n-    def parse(self):\n-        (typelen,) = struct.unpack(\"!H\",self.arr[0:2])\n-        self.tlv_type = typelen >> 9\n-        self.len  = typelen & 0x01ff\n-        self.next = self.arr[2:]\n-        self.parsed = True\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.len & 0x01ff)\n-        return struct.pack('!H', typelen) + self.next\n-\n-class unknown_tlv (basic_tlv):\n-    tlv_type = None\n-\n-class system_description (basic_tlv):\n-    tlv_type = lldp.SYSTEM_DESC_TLV\n-\n-class management_address (object):\n-    tlv_type = lldp.MANAGEMENT_ADDR_TLV\n-\n-    def __init__ (self, raw = None):\n-        self.address_subtype = 0\n-        self.address = b''\n-        self.interface_numbering_subtype = 0\n-        self.interface_number = 0\n-        self.object_identifier = b''\n-\n-        if raw is not None:\n-            self.parse(raw)\n-\n-    def parse (self, data):\n-        typelen = struct.unpack(\"!H\",data[0:2])[0]\n-        self.tlv_type = typelen >> 9\n-        length  = typelen & 0x01ff\n-\n-        asl = ord(data[2]) - 1\n-        self.address_subtype = ord(data[3])\n-        self.address = data[4:4+asl]\n-\n-        self.interface_numbering_subtype = ord(data[4+asl])\n-        self.interface_number = struct.unpack(\"!L\",\n-                                              data[4+asl+1:4+asl+1+4])[0]\n-        osl = ord(data[9+asl])\n-        self.object_identifier = data[9+asl+1:9+asl+1+osl]\n-\n-    def __len__ (self):\n-        return 2+1+1+len(self.address)+1+4+1+len(self.object_identifier)\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | ((len(self)-2) & 0x01ff)\n-        r = struct.pack('!H', typelen)\n-        r += struct.pack('!BB', len(self.address)+1, self.address_subtype)\n-        r += self.address\n-        r += struct.pack(\"!BLB\", self.interface_numbering_subtype,\n-                         self.interface_number,\n-                         len(self.object_identifier))\n-        r += self.object_identifier\n-        return r\n-\n-class system_name (basic_tlv):\n-    tlv_type = lldp.SYSTEM_NAME_TLV\n-\n-class organizationally_specific (basic_tlv):\n-    tlv_type = lldp.ORGANIZATIONALLY_SPECIFIC_TLV\n-    def __init__ (self, raw = None):\n-        self.oui = '\\x00\\x00\\x00'\n-        self.subtype = 0\n-        self.next = bytes()\n-        basic_tlv.__init__(self, raw)\n-      \n-    def parse (self):\n-        basic_tlv.parse(self)\n-        (self.oui,self.subtype) = struct.unpack(\"3sB\", self.next[0:4])\n-        self.next = self.next[4:]\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.len & 0x01ff)\n-        return struct.pack('!H3sB', typelen, self.oui, self.subtype) + self.next\n-\n-class port_description (basic_tlv):\n-    tlv_type = lldp.PORT_DESC_TLV\n-\n-class system_capabilities (basic_tlv):\n-    tlv_type = lldp.SYSTEM_CAP_TLV\n-\n-    cap_names = [\"Other\", \"Repeater\", \"Bridge\", \"WLAN Access Point\",\n-                 \"Router\", \"Telephone\", \"DOCSIS cable device\",\n-                 \"Station Only\"]\n-\n-    def __init__ (self, raw = None):\n-        self.caps = [False] * 16\n-        self.enabled_caps = [False] * 16\n-        basic_tlv.__init__(self, raw)\n-      \n-    def parse (self):\n-        basic_tlv.parse(self)\n-        (cap,en) = struct.unpack(\"!HH\", self.next)\n-        del self.caps[:]\n-        del self.enabled_caps[:]\n-        for i in range(0, 16):\n-            self.caps.append(True if (cap and (1 << i)) else False)\n-            self.enabled_caps.append(True if (en and (1 << i)) else False)\n-\n-    def pack(self):\n-        typelen = 0\n-        typelen = self.tlv_type << 9\n-        typelen = typelen | (self.len & 0x01ff)\n-        cap = 0\n-        en = 0\n-        for i in range(0, 16):\n-            if self.caps[i]: cap |= (1 << i)\n-            if self.enabled_caps[i]: en |= (1 << i)\n-        return struct.pack('!HHH', typelen, cap, en)\n-\n-    def __str__ (self):\n-        r = []\n-        for i in range(0, 16):\n-            if self.caps[i]:\n-                if i < len(self.cap_names):\n-                    s = self.cap_names[i]\n-                else:\n-                    s = \"Capability \" + str(i)\n-                s += \":\" + (\"On\" if self.enabled_caps[i] else \"Off\")\n-                r.append(s)\n-        return \"<Capabilities: \" + ', '.join(r) + \">\"\n+  def __str__ (self):\n+    if self.subtype == chassis_id.SUB_MAC:\n+      assert len(self.id) == 6\n+      id_str = str(EthAddr(self.id))\n+    else:\n+      id_str = \":\".join([\"%02x\" % (ord(x),) for x in self.id])\n+\n+    return ''.join(['<chasis ID:',id_str,'>'])\n+\n+\n+class port_id (simple_tlv):\n+  tlv_type = lldp.PORT_ID_TLV\n+\n+  SUB_IF_ALIAS = 1 # IETF RFC 2863\n+  SUB_PORT     = 2 # IETF RFC 2737\n+  SUB_MAC      = 3 # IEEE Std 802-2001\n+  SUB_NETWORK  = 4 #\n+  SUB_IF_NAME  = 5 # IETF RFC 2863\n+  SUB_CIRC_ID  = 6 # IETF RFC 3046\n+  SUB_LOCAL    = 7\n+\n+  subtype_to_str = {}\n+  subtype_to_str[SUB_IF_ALIAS] = \"interface alias\"\n+  subtype_to_str[SUB_PORT]     = \"port\"\n+  subtype_to_str[SUB_MAC]      = \"mac\"\n+  subtype_to_str[SUB_NETWORK]  = \"network\"\n+  subtype_to_str[SUB_IF_NAME]  = \"interface name\"\n+  subtype_to_str[SUB_CIRC_ID]  = \"agent circuit ID\"\n+  subtype_to_str[SUB_LOCAL]    = \"local\"\n+\n+  def _init (self, kw):\n+    self.subtype = 0\n+    self.id      = None\n+\n+  def _parse_data (self, data):\n+    if len(data) < 2:\n+      raise MalformedException(\"TLV has invalid strlen\")\n+\n+    (self.subtype,) = struct.unpack(\"!B\",data[0:1])\n+    self.id = data[1:]\n+\n+  def __str__ (self):\n+    if self.subtype == chassis_id.SUB_MAC:\n+      assert len(self.id) == 6\n+      id_str = str(EthAddr(self.id))\n+    else:\n+      id_str = \":\".join([\"%02x\" % (ord(x),) for x in self.id])\n+\n+    return ''.join(['<port ID:',id_str,'>'])\n+\n+  def _pack_data (self):\n+    return struct.pack(\"!B\", self.subtype) + self.id\n+\n+\n+class ttl (simple_tlv):\n+  tlv_type = lldp.TTL_TLV\n+\n+  def _init (self, kw):\n+    self.ttl = 0\n+\n+  def _parse_data (self, data):\n+    if len(data) != 2:\n+      raise MalformedException(\"TLV has invalid strlen (!= 2)\")\n+    (self.ttl,) = struct.unpack(\"!H\",data[0:2])\n+\n+  def __str__ (self):\n+    return ''.join(['<ttl:',str(self.ttl),'>'])\n+\n+  def _pack_data (self):\n+    return struct.pack('!H', self.ttl)\n+\n+\n+class end_tlv (simple_tlv):\n+  tlv_type = lldp.END_TLV\n+\n+  def _parse_data (self, data):\n+    if len(data) != 0:\n+      raise MalformedException(\"TLV has invalid strlen (!= 0)\")\n+\n+  def __str__ (self):\n+    return '<tlv end>'\n+\n+  def _pack_data (self):\n+    return b''\n+\n+\n+class system_description (simple_tlv):\n+  tlv_type = lldp.SYSTEM_DESC_TLV\n+\n+\n+class management_address (simple_tlv):\n+  tlv_type = lldp.MANAGEMENT_ADDR_TLV\n+\n+  def _init (self, kw):\n+    self.address_subtype = 0\n+    self.address = b''\n+    self.interface_numbering_subtype = 0\n+    self.interface_number = 0\n+    self.object_identifier = b''\n+\n+  def _parse_data (self, data):\n+    asl = ord(data[0]) - 1\n+    self.address_subtype = ord(data[1])\n+    self.address = data[2:2+asl]\n+\n+    self.interface_numbering_subtype = ord(data[2+asl])\n+    self.interface_number = struct.unpack(\"!L\",\n+                                      data[2+asl+1:2+asl+1+4])[0]\n+    osl = ord(data[7+asl])\n+    self.object_identifier = data[7+asl+1:7+asl+1+osl]\n+\n+  def _data_len (self):\n+    return 1+1+len(self.address)+1+4+1+len(self.object_identifier)\n+\n+  def _pack_data (self):\n+    r = struct.pack('!BB', len(self.address)+1, self.address_subtype)\n+    r += self.address\n+    r += struct.pack(\"!BLB\", self.interface_numbering_subtype,\n+                     self.interface_number,\n+                     len(self.object_identifier))\n+    r += self.object_identifier\n+    return r\n+\n+\n+class system_name (simple_tlv):\n+  tlv_type = lldp.SYSTEM_NAME_TLV\n+\n+\n+class organizationally_specific (simple_tlv):\n+  tlv_type = lldp.ORGANIZATIONALLY_SPECIFIC_TLV\n+\n+  def _init (self, kw):\n+    self.oui = '\\x00\\x00\\x00'\n+    self.subtype = 0\n+    self.payload = b''\n+\n+  def _parse_data (self, data):\n+    (self.oui,self.subtype) = struct.unpack(\"3sB\", data[0:4])\n+    self.payload = data[4:]\n+\n+  def _pack_data (self):\n+    return struct.pack('!3sB', self.oui, self.subtype) + self.payload\n+\n+\n+class port_description (simple_tlv):\n+  tlv_type = lldp.PORT_DESC_TLV\n+\n+\n+class system_capabilities (simple_tlv):\n+  tlv_type = lldp.SYSTEM_CAP_TLV\n+\n+  cap_names = [\"Other\", \"Repeater\", \"Bridge\", \"WLAN Access Point\",\n+         \"Router\", \"Telephone\", \"DOCSIS cable device\",\n+         \"Station Only\"]\n+\n+  def _init (self, kw):\n+    self.caps = [False] * 16\n+    self.enabled_caps = [False] * 16\n+\n+  def _parse_data (self, data):\n+    (cap,en) = struct.unpack(\"!HH\", data)\n+    del self.caps[:]\n+    del self.enabled_caps[:]\n+    for i in range(0, 16):\n+      self.caps.append(True if (cap & (1 << i)) else False)\n+      self.enabled_caps.append(True if (en & (1 << i)) else False)\n+\n+  def _pack_data (self):\n+    cap = 0\n+    en = 0\n+    for i in range(0, 16):\n+      if self.caps[i]: cap |= (1 << i)\n+      if self.enabled_caps[i]: en |= (1 << i)\n+    return struct.pack('!HH', cap, en)\n+\n+  def __str__ (self):\n+    r = []\n+    for i in range(0, 16):\n+      if self.caps[i]:\n+        if i < len(self.cap_names):\n+            s = self.cap_names[i]\n+        else:\n+            s = \"Capability \" + str(i)\n+        s += \":\" + (\"On\" if self.enabled_caps[i] else \"Off\")\n+        r.append(s)\n+    return \"<Capabilities: \" + ', '.join(r) + \">\"\n \n \n # Add parsers to main lldp class\n for t in [chassis_id, port_id, ttl, system_name, system_description,\n-          end_tlv, organizationally_specific, port_description,\n-          system_capabilities, management_address]:\n-    lldp.tlv_parsers[t.tlv_type] = t\n+      end_tlv, organizationally_specific, port_description,\n+      system_capabilities, management_address]:\n+  lldp.tlv_parsers[t.tlv_type] = t\ndiff --git a/pox/openflow/discovery_new.py b/pox/openflow/discovery_new.py\nindex f3710de..a701fc1 100644\n--- a/pox/openflow/discovery_new.py\n+++ b/pox/openflow/discovery_new.py\n@@ -36,7 +36,7 @@ from collections import namedtuple\n from random import shuffle, random\n \n \n-log = core.getLogger()\n+#log = core.getLogger()\n \n \n class LLDPSender (object):\n@@ -65,6 +65,7 @@ class LLDPSender (object):\n       consider the rest of the data to be valid.  We don't use this, but\n       other LLDP agents might.  Can't be 0 (this means revoke).\n     \"\"\"\n+    self.log = core.getLogger(\"LLDPSender\")\n     # Packets remaining to be sent in this cycle\n     self._this_cycle = []\n \n@@ -77,18 +78,23 @@ class LLDPSender (object):\n     self._timer = None\n     self._ttl = ttl\n     self._send_cycle_time = send_cycle_time\n-    #core.listen_to_dependencies(self)\n+    core.openflow.addListenerByName(\"PortStatus\", self._handle_openflow_PortStatus)\n+    core.openflow.addListenerByName(\"ConnectionUp\", self._handle_openflow_ConnectionUp)\n+    core.openflow.addListenerByName(\"ConnectionDown\", self._handle_openflow_ConnectionDown)\n \n   def _handle_openflow_PortStatus (self, event):\n     \"\"\"\n     Track changes to switch ports\n     \"\"\"\n+    self.log.debug(\"_handle_openflow_PortStatus: dpid=%s, port=%d\", event.dpid, event.port)\n     if event.added:\n       self.add_port(event.dpid, event.port, event.ofp.desc.hw_addr)\n     elif event.deleted:\n       self.del_port(event.dpid, event.port)\n \n   def _handle_openflow_ConnectionUp (self, event):\n+    self.log.debug(\"_handle_openflow_ConnectionUp: dpid=%s\", event.dpid)\n+\n     self.del_switch(event.dpid, set_timer = False)\n \n     ports = [(p.port_no, p.hw_addr) for p in event.ofp.ports]\n@@ -99,6 +105,7 @@ class LLDPSender (object):\n     self._set_timer()\n \n   def _handle_openflow_ConnectionDown (self, event):\n+    self.log.debug(\"_handle_openflow_ConnectionDown: dpid=%s\", event.dpid)\n     self.del_switch(event.dpid)\n \n   def del_switch (self, dpid, set_timer = True):\n@@ -165,7 +172,9 @@ class LLDPSender (object):\n     Create an ofp_packet_out containing a discovery packet\n     \"\"\"\n     eth = self._create_discovery_packet(dpid, port_num, port_addr, self._ttl)\n+    self.log.debug(\"Created discovery packet dpid=%s, port_num=%s, port_addr=%s, self._ttl=%s\", dpid, port_num, port_addr, self._ttl)\n     po = of.ofp_packet_out(action = of.ofp_action_output(port=port_num))\n+    self.log.debug(\"YYY Packet out created create_packet_out buffer %s\", po.buffer_id)\n     po.data = eth.pack()\n     return po.pack()\n \n@@ -206,6 +215,7 @@ class LinkEvent (Event):\n   Link up/down event\n   \"\"\"\n   def __init__ (self, add, link, event = None):\n+    Event.__init__(self)\n     self.link = link\n     self.added = add\n     self.removed = not add\n@@ -259,12 +269,13 @@ class Discovery (EventMixin):\n     LinkEvent,\n   ])\n \n-  _core_name = \"openflow_discovery\" # we want to be core.openflow_discovery\n+  _core_name = \"openflow_discovery_new\" # we want to be core.openflow_discovery\n \n   Link = Link\n \n   def __init__ (self, install_flow = True, explicit_drop = True,\n                 link_timeout = None, eat_early_packets = False):\n+    self.log = core.getLogger('Discovery')\n     self._eat_early_packets = eat_early_packets\n     self._explicit_drop = explicit_drop\n     self._install_flow = install_flow\n@@ -274,22 +285,33 @@ class Discovery (EventMixin):\n     self._sender = LLDPSender(self.send_cycle_time)\n \n     # Listen with a high priority (mostly so we get PacketIns early)\n-    #core.listen_to_dependencies(self,\n-    #    listen_args={'openflow':{'priority':0xffffffff}})\n-\n+    if core.hasComponent(\"openflow\"):\n+      self.log.debug(\"Listening to openflow\")\n+      self.listenTo(core.openflow, prefix='openflow', priority=0xffffffff)\n+    else:\n+      # We'll wait for openflow to come up\n+      self.log.debug(\"Listening to core\")\n+      self.listenTo(core)\n     Timer(self._timeout_check_period, self._expire_links, recurring=True)\n \n+  def _handle_ComponentRegistered (self, event):\n+    if event.name == \"openflow\":\n+      self.log.debug(\"Listening to openflow\")\n+      self.listenTo(core.openflow, prefix='openflow', priority=0xffffffff)\n+      return EventRemove # We don't need this listener anymore\n+\n   @property\n   def send_cycle_time (self):\n     return self._link_timeout / 2.0\n \n   def install_flow (self, con_or_dpid, priority = None):\n+    self.log.debug(\"Install flow begin for LLDP\")\n     if priority is None:\n       priority = self._flow_priority\n     if isinstance(con_or_dpid, (int,long)):\n       con = core.openflow.connections.get(con_or_dpid)\n       if con is None:\n-        log.warn(\"Can't install flow for %s\", dpidToStr(con_or_dpid))\n+        self.log.warn(\"Can't install LLDP flow for %s\", dpidToStr(con_or_dpid))\n         return False\n     else:\n       con = con_or_dpid\n@@ -301,16 +323,18 @@ class Discovery (EventMixin):\n     msg.match = match\n     msg.actions.append(of.ofp_action_output(port = of.OFPP_CONTROLLER))\n     con.send(msg)\n+    self.log.debug(\"Finished installing LLDP flow at %s\", con)\n     return True\n \n   def _handle_openflow_ConnectionUp (self, event):\n     if self._install_flow:\n       # Make sure we get appropriate traffic\n-      log.debug(\"Installing flow for %s\", dpidToStr(event.dpid))\n+      self.log.debug(\"Connection Up for dpid='%s'\", dpidToStr(event.dpid))\n       self.install_flow(event.connection)\n \n   def _handle_openflow_ConnectionDown (self, event):\n     # Delete all links on this switch\n+    self.log.debug(\"Connection Down for dpid='%s'\", dpidToStr(event.dpid))\n     self._delete_links([link for link in self.adjacency\n                         if link.dpid1 == event.dpid\n                         or link.dpid2 == event.dpid])\n@@ -325,7 +349,7 @@ class Discovery (EventMixin):\n                if timestamp + self._link_timeout < now]\n     if expired:\n       for link in expired:\n-        log.info('link timeout: %s', link)\n+        self.log.info('link timeout: %s', link)\n \n       self._delete_links(expired)\n \n@@ -333,41 +357,50 @@ class Discovery (EventMixin):\n     \"\"\"\n     Receive and process LLDP packets\n     \"\"\"\n-\n     packet = event.parsed\n+    self.log.info(\"Packet in src: %s, dst: %s, buffer_id: %s\", packet.src, packet.dst, event.ofp.buffer_id)\n \n-    if (packet.effective_ethertype != pkt.ethernet.LLDP_TYPE\n+    if (packet.type != pkt.ethernet.LLDP_TYPE\n         or packet.dst != pkt.ETHERNET.NDP_MULTICAST):\n-      if not self._eat_early_packets: return\n-      if not event.connection.connect_time: return\n+      if not self._eat_early_packets:\n+        self.log.debug(\"Don't eat the packet\")\n+        return\n+      if not event.connection.connect_time:\n+        self.log.debug(\"Still connecting\")\n+        return\n       enable_time = time.time() - self.send_cycle_time - 1\n       if event.connection.connect_time > enable_time:\n+        self.log.debug(\"connect_time > enable_time\")\n         return EventHalt\n       return\n \n     if self._explicit_drop:\n       if event.ofp.buffer_id is not None:\n-        log.debug(\"Dropping LLDP packet %i\", event.ofp.buffer_id)\n+        self.log.debug(\"Dropping LLDP packet on switch='%s' and buffer_id='%i'\",\n+                       dpidToStr(event.dpid), event.ofp.buffer_id)\n         msg = of.ofp_packet_out()\n         msg.buffer_id = event.ofp.buffer_id\n         msg.in_port = event.port\n+        event.ofp.buffer_id = None # Mark is dead\n         event.connection.send(msg)\n+      else:\n+        self.log.debug(\"Not dropping LLDP because buffer id is None\")\n \n     lldph = packet.find(pkt.lldp)\n     if lldph is None or not lldph.parsed:\n-      log.error(\"LLDP packet could not be parsed\")\n+      self.log.error(\"LLDP packet could not be parsed\")\n       return EventHalt\n     if len(lldph.tlvs) < 3:\n       log.error(\"LLDP packet without required three TLVs\")\n       return EventHalt\n     if lldph.tlvs[0].tlv_type != pkt.lldp.CHASSIS_ID_TLV:\n-      log.error(\"LLDP packet TLV 1 not CHASSIS_ID\")\n+      self.log.error(\"LLDP packet TLV 1 not CHASSIS_ID\")\n       return EventHalt\n     if lldph.tlvs[1].tlv_type != pkt.lldp.PORT_ID_TLV:\n-      log.error(\"LLDP packet TLV 2 not PORT_ID\")\n+      self.log.error(\"LLDP packet TLV 2 not PORT_ID\")\n       return EventHalt\n     if lldph.tlvs[2].tlv_type != pkt.lldp.TTL_TLV:\n-      log.error(\"LLDP packet TLV 3 not TTL\")\n+      self.log.error(\"LLDP packet TLV 3 not TTL\")\n       return EventHalt\n \n     def lookInSysDesc ():\n@@ -413,16 +446,16 @@ class Discovery (EventMixin):\n               pass\n \n     if originatorDPID == None:\n-      log.warning(\"Couldn't find a DPID in the LLDP packet\")\n+      self.log.warning(\"Couldn't find a DPID in the LLDP packet\")\n       return EventHalt\n \n     if originatorDPID not in core.openflow.connections:\n-      log.info('Received LLDP packet from unknown switch')\n+      self.log.info('Received LLDP packet from unknown switch')\n       return EventHalt\n \n     # Get port number from port TLV\n     if lldph.tlvs[1].subtype != pkt.port_id.SUB_PORT:\n-      log.warning(\"Thought we found a DPID, but packet didn't have a port\")\n+      self.log.warning(\"Thought we found a DPID, but packet didn't have a port\")\n       return EventHalt\n     originatorPort = None\n     if lldph.tlvs[1].id.isdigit():\n@@ -435,20 +468,21 @@ class Discovery (EventMixin):\n       except:\n         pass\n     if originatorPort is None:\n-      log.warning(\"Thought we found a DPID, but port number didn't \" +\n+      self.log.warning(\"Thought we found a DPID, but port number didn't \" +\n                   \"make sense\")\n       return EventHalt\n \n     if (event.dpid, event.port) == (originatorDPID, originatorPort):\n-      log.warning(\"Port received its own LLDP packet; ignoring\")\n+      self.log.warning(\"Port received its own LLDP packet; ignoring\")\n       return EventHalt\n \n     link = Discovery.Link(originatorDPID, originatorPort, event.dpid,\n                           event.port)\n \n+    self.log.info(\"Link %s\", link)\n     if link not in self.adjacency:\n       self.adjacency[link] = time.time()\n-      log.info('link detected: %s', link)\n+      self.log.info('link detected: %s', link)\n       self.raiseEventNoErrors(LinkEvent, True, link, event)\n     else:\n       # Just update timestamp\n@@ -458,6 +492,7 @@ class Discovery (EventMixin):\n \n   def _delete_links (self, links):\n     for link in links:\n+      self.log.info('link deleted: %s', link)\n       self.raiseEventNoErrors(LinkEvent, False, link)\n     for link in links:\n       self.adjacency.pop(link, None)\ndiff --git a/pox/openflow/libopenflow_01.py b/pox/openflow/libopenflow_01.py\nindex 8c72ebd..8cf64c7 100644\n--- a/pox/openflow/libopenflow_01.py\n+++ b/pox/openflow/libopenflow_01.py\n@@ -3013,7 +3013,7 @@ class ofp_packet_out (ofp_header):\n     self.buffer_id = -1\n     self.in_port = OFPP_NONE\n     self.actions = []\n-    self._data = ''\n+    self._data = b''\n \n     # ofp_flow_mod and ofp_packet_out do some special handling of 'actions'...\n \n@@ -3026,7 +3026,7 @@ class ofp_packet_out (ofp_header):\n     # Allow use of actions=<a single action> for kw args.\n     if not hasattr(self.actions, '__getitem__'):\n       self.actions = [self.actions]\n-\n+  \"\"\"\n   def _set_data(self, data):\n     assert_type(\"data\", data, (packet_base, str))\n     if data is None:\n@@ -3038,9 +3038,39 @@ class ofp_packet_out (ofp_header):\n   def _get_data(self):\n     return self._data\n   data = property(_get_data, _set_data)\n+  \"\"\"\n+  @property\n+  def data (self):\n+    return self._data\n+  @data.setter\n+  def data (self, data):\n+    if data is None:\n+      self._data = b''\n+    elif isinstance(data, packet_base):\n+      self._data = data.pack()\n+    elif isinstance(data, ofp_packet_in):\n+      # Enable you to easily resend a packet\n+      self._data = b''\n+      self.buffer_id = data.buffer_id\n+      if self.buffer_id is None:\n+        #TODO: It'd be nice to log and then ignore if data is incomplete\n+        #      Unfortunately, we currently have no logging in here, so we\n+        #      assert instead which is a either too drastic or too quiet.\n+        assert data.is_complete\n+        self._data = data._data\n+      self.in_port = data.in_port\n+    elif isinstance(data, bytes):\n+      self._data = data\n+    assert assert_type(\"data\", self._data, (bytes,))\n+\n+  def _validate (self):\n+    if self.buffer_id is not None and self.data != b'':\n+      return \"can not have both buffer_id and data set\"\n+    return None\n+\n \n   def _assert (self):\n-    if self.buffer_id != -1 and self.data != '':\n+    if self.buffer_id != -1 and self.data != b'':\n       return \"can not have both buffer_id and data set\"\n     return True\n \n@@ -3191,7 +3221,7 @@ class ofp_packet_in (ofp_header):\n     ofp_header.__init__(self)\n \n     self.in_port = OFPP_NONE\n-    self.buffer_id = -1\n+    self._buffer_id = NO_BUFFER\n     self.reason = 0\n     self.data = None\n \n@@ -3200,6 +3230,15 @@ class ofp_packet_in (ofp_header):\n     self.header_type = OFPT_PACKET_IN\n     self._total_len = 0\n \n+  @property\n+  def buffer_id (self):\n+    if self._buffer_id == NO_BUFFER: return None\n+    return self._buffer_id\n+  @buffer_id.setter\n+  def buffer_id (self, val):\n+    if val is None: val = NO_BUFFER\n+    self._buffer_id = val\n+\n   def _set_data(self, data):\n     assert_type(\"data\", data, (packet_base, str))\n     if data is None:\n@@ -3222,13 +3261,19 @@ class ofp_packet_in (ofp_header):\n     if assertstruct:\n       if not self._assert()[0]:\n         raise AssertionError(self._assert()[1])\n+\n+    buffer_id = self.buffer_id\n+    if buffer_id is None:\n+      buffer_id = NO_BUFFER\n+\n+\n     packed = \"\"\n     # need to update the self.length field for ofp_header.pack to put the correct value in the packed\n     # array. this sucks.\n     self.length = len(self)\n     self._total_len = len(self) # TODO: Is this correct?\n     packed += ofp_header.pack(self)\n-    packed += struct.pack(\"!LHHBB\", self.buffer_id & 0xffFFffFF, self._total_len, self.in_port, self.reason, 0)\n+    packed += struct.pack(\"!LHHBB\", buffer_id, self._total_len, self.in_port, self.reason, 0)\n     packed += self.data\n     return packed\n \n@@ -3237,8 +3282,8 @@ class ofp_packet_in (ofp_header):\n       return binaryString\n     ofp_header.unpack(self, binaryString[0:])\n     (self.buffer_id, self._total_len, self.in_port, self.reason, pad) = struct.unpack_from(\"!LHHBB\", binaryString, 8)\n-    if self.buffer_id == 0xFFffFFff:\n-      self.buffer_id = -1\n+    if self.buffer_id == NO_BUFFER:\n+      self.buffer_id = NO_BUFFER\n     if (len(binaryString) < self.length):\n       return binaryString\n     self.data = binaryString[18:self.length]\ndiff --git a/pox/openflow/spanning_tree_new.py b/pox/openflow/spanning_tree_new.py\nindex 86e812a..e00bbb8 100644\n--- a/pox/openflow/spanning_tree_new.py\n+++ b/pox/openflow/spanning_tree_new.py\n@@ -58,7 +58,7 @@ def _calc_spanning_tree ():\n   adj = defaultdict(lambda:defaultdict(lambda:[]))\n   switches = set()\n   # Add all links and switches\n-  for l in core.openflow_discovery.adjacency:\n+  for l in core.openflow_discovery_new.adjacency:\n     adj[l.dpid1][l.dpid2].append(l)\n     switches.add(l.dpid1)\n     switches.add(l.dpid2)\n@@ -73,7 +73,7 @@ def _calc_spanning_tree ():\n       assert s1 is not s2\n       good = False\n       for l in adj[s1][s2]:\n-        if flip(l) in core.openflow_discovery.adjacency:\n+        if flip(l) in core.openflow_discovery_new.adjacency:\n           # This is a good one\n           adj[s1][s2] = l.port1\n           adj[s2][s1] = l.port2\n@@ -132,13 +132,14 @@ _hold_down = False\n \n \n def _handle_ConnectionUp (event):\n+  log.debug(\"Spanning _handle_ConnectionUp: %s\", event.dpid)\n   # When a switch connects, forget about previous port states\n   _prev[event.dpid].clear()\n \n   if _noflood_by_default:\n     con = event.connection\n     log.debug(\"Disabling flooding for %i ports\", len(con.ports))\n-    for p in con.ports.itervalues():\n+    for p in con.features.ports:\n       if p.port_no >= of.OFPP_MAX: continue\n       _prev[con.dpid][p.port_no] = False\n       pm = of.ofp_port_mod(port_no=p.port_no,\n@@ -149,13 +150,13 @@ def _handle_ConnectionUp (event):\n     _invalidate_ports(con.dpid)\n \n   if _hold_down:\n-    t = Timer(core.openflow_discovery.send_cycle_time + 1, _update_tree,\n+    t = Timer(core.openflow_discovery_new.send_cycle_time + 1, _update_tree,\n               kw={'force_dpid':event.dpid})\n \n \n def _handle_LinkEvent (event):\n   # When links change, update spanning tree\n-\n+  log.debug(\"LinkEvent: %s\", event.link)\n   (dp1,p1),(dp2,p2) = event.link.end\n   if _prev[dp1][p1] is False:\n     if _prev[dp2][p2] is False:\n@@ -181,7 +182,7 @@ def _update_tree (force_dpid = None):\n   # Connections born before this time are old enough that a complete\n   # discovery cycle should have completed (and, thus, all of their\n   # links should have been discovered).\n-  enable_time = time.time() - core.openflow_discovery.send_cycle_time - 1\n+  enable_time = time.time() - core.openflow_discovery_new.send_cycle_time - 1\n \n   # Now modify ports as needed\n   try:\n@@ -201,11 +202,11 @@ def _update_tree (force_dpid = None):\n             continue\n \n       tree_ports = [p[1] for p in ports]\n-      for p in con.ports.itervalues():\n+      for p in con.features.ports:\n         if p.port_no < of.OFPP_MAX:\n           flood = p.port_no in tree_ports\n           if not flood:\n-            if core.openflow_discovery.is_edge_port(sw, p.port_no):\n+            if core.openflow_discovery_new.is_edge_port(sw, p.port_no):\n               flood = True\n           if _prev[sw][p.port_no] is flood:\n             #print sw,p.port_no,\"skip\",\"(\",flood,\")\"\n@@ -269,9 +270,8 @@ class SpanningTreeNew (EventMixin):\n     pass\n \n   def start_spanning_tree (self):\n-    print \"XXXX spanning tree is up\"\n     core.openflow.addListenerByName(\"ConnectionUp\", _handle_ConnectionUp)\n-    core.openflow_discovery.addListenerByName(\"LinkEvent\", _handle_LinkEvent)\n+    core.openflow_discovery_new.addListenerByName(\"LinkEvent\", _handle_LinkEvent)\n     log.debug(\"Spanning tree component ready\")\n \n def launch (no_flood = False, hold_down = False):\n@@ -285,4 +285,3 @@ def launch (no_flood = False, hold_down = False):\n   core.registerNew(SpanningTreeNew)\n \n   #core.call_when_ready(start_spanning_tree, \"openflow_discovery\")\n-",
      "status": "On branch backport_l2_multi\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   pox/forwarding/l2_multi_new.py\n\tmodified:   pox/lib/packet/lldp.py\n\tmodified:   pox/openflow/discovery_new.py\n\tmodified:   pox/openflow/libopenflow_01.py\n\tmodified:   pox/openflow/spanning_tree_new.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    },
    "sts": {
      "branch": "hb-dev-onos",
      "commit": "2f1b7c2e2bec42db14d68fdf7d4778fde6fb21bf",
      "diff": "diff --cc config/floodlight_loxigen.py\nindex de96785,c4937df..0000000\n--- a/config/floodlight_loxigen.py\n+++ b/config/floodlight_loxigen.py\n@@@ -16,23 -16,21 +16,35 @@@ start_cmd = ('''java -ea -Dlogback.conf\n  \n  # Uncomment this if you are running Floodlight separately, e.g. for debugging in Eclipse. There must be a controller listening on port 6633.\n  start_cmd = '''echo \"no-op\"'''\n +controllers = [ControllerConfig(start_cmd, cwd='../../floodlight/floodlight', address=\"127.0.0.1\", port=6653, controller_type='dummy')]\n +\n++<<<<<<< Updated upstream:config/floodlight_loxigen.py\n +num = 2\n++||||||| merged common ancestors\n++controllers = [ControllerConfig(start_cmd, controller_type='dummy', cwd='./', address=\"192.168.56.200\", port=6633)]\n++\n++\n+ \n++=======\n+ controllers = [ControllerConfig(start_cmd, controller_type='dummy', cwd='./', address=\"192.168.56.202\", port=6633)]\n+ \n+ \n+ \n++>>>>>>> Stashed changes:config/trace_onos_hb_learningswitch.py\n  topology_class = StarTopology\n -topology_params = \"num_hosts=2\"\n +topology_params = \"num_hosts=%d\" % num\n +#topology_class = MeshTopology\n +#topology_params = \"num_switches=%d\" % num\n +# topology_class = GridTopology\n +# topology_params = \"num_rows=3, num_columns=3\"\n +# topology_class = BinaryLeafTreeTopology\n +# topology_params = \"num_levels=%d\" % num\n  \n -# Where should the output files be written to\n -results_dir = \"traces/trace_onos_hb_learningswitch-star2\"\n +steps = 400\n +results_dir = \"traces/floodlight_loxigen-%s%d-steps%s\" % (topology_class.__name__, num, steps)\n  \n -#apps = [AppCircuitPusher('circuitpusher', cwd='../floodlight/apps/circuitpusher', runtime='python', script='circuitpusher.py', controller='localhost:8080')]\n -apps = None\n +apps = []\n  \n -# include all defaults\n  simulation_config = SimulationConfig(controller_configs=controllers,\n                                       topology_class=topology_class,\n                                       topology_params=topology_params,\n@@@ -54,13 -52,13 +66,39 @@@\n  \n  control_flow = Fuzzer(simulation_config,\n                        input_logger=InputLogger(),\n++<<<<<<< Updated upstream:config/floodlight_loxigen.py\n +                      initialization_rounds=20,\n +                      send_all_to_all=True, # needs to be True otherwise circuitpusher will throw errors.\n++||||||| merged common ancestors\n++                      initialization_rounds=20,\n++                      send_all_to_all=False,\n++=======\n+                       initialization_rounds=30,\n+                       send_all_to_all=False,\n++>>>>>>> Stashed changes:config/trace_onos_hb_learningswitch.py\n                        check_interval=10,\n                        delay=0.1,\n++<<<<<<< Updated upstream:config/floodlight_loxigen.py\n +                      halt_on_violation=True,\n +                      send_init_packets=False,\n +                      steps=steps, # if no circuits are installed, increase this number.\n++||||||| merged common ancestors\n++                      halt_on_violation=False,\n++                      steps=150,\n++                      delay_startup=False,\n++=======\n+                       halt_on_violation=False,\n+                       steps=200,\n+                       delay_startup=False,\n++>>>>>>> Stashed changes:config/trace_onos_hb_learningswitch.py\n  #                       invariant_check_name=\"check_everything\",\n++<<<<<<< Updated upstream:config/floodlight_loxigen.py\n++                      invariant_check_name=\"InvariantChecker.check_liveness\",\n++                      apps=apps)\n++||||||| merged common ancestors\n++                      invariant_check_name=\"InvariantChecker.check_noop\",\n++                      apps=apps)\n++=======\n                        invariant_check_name=\"InvariantChecker.check_liveness\",\n-                       apps=apps)\n+                       apps=apps)\n++>>>>>>> Stashed changes:config/trace_onos_hb_learningswitch.py\ndiff --cc pox\nindex b6352b7,43004a1..0000000\n--- a/pox\n+++ b/pox",
      "status": "On branch hb-dev-onos\nYour branch is up-to-date with 'origin/hb-dev-onos'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tmodified:   config/fuzzer_params.py\n\tmodified:   config/trace_floodlight_learningswitch.py\n\tmodified:   config/trace_pox_l2_consistency.py\n\tmodified:   config/trace_pox_l2_multi.py\n\nUnmerged paths:\n  (use \"git reset HEAD <file>...\" to unstage)\n  (use \"git add <file>...\" to mark resolution)\n\n\tboth modified:   config/floodlight_loxigen.py\n\tboth modified:   pox\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tconfig/pox_consistency.py\n\tconfig/trace_pox_l2_multi_new.py\n\tgen.sh~\n\tmultipage.pdf\n\tshort.txt"
    }
  },
  "sys": {
    "lsb_release": "Ubuntu 15.04",
    "uname": "Linux stsdev 3.19.0-26-generic #28-Ubuntu SMP Tue Aug 11 14:16:32 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux"
  },
  "timestamp": "2015_10_29_23_07_06",
  "user": "ahassany"
}
