{
  "additional_metadata": null,
  "argv": [
    "./simulator.py",
    "-c",
    "config/trace_pox_l2_consistency.py"
  ],
  "cwd": "/home/ahassany/repos/jsts",
  "host": {
    "cpu_info": "Intel(R) Core(TM) i7-4870HQ CPU @ 2.50GHz",
    "free": "total       used       free     shared    buffers     cached\nMem:       4045244     285708    3759536       5664      22512     164864\n-/+ buffers/cache:      98332    3946912\nSwap:      4192252          0    4192252",
    "name": "stsdev",
    "num_cores": "2",
    "uptime": "18:14:22 up 15:17,  1 user,  load average: 0.09, 0.06, 0.05"
  },
  "modules": {
    "hassel": {
      "branch": "HEAD",
      "commit": "31afb29fa66783f5a66765bc186509b65ffc023e",
      "diff": "",
      "status": "HEAD detached at 31afb29\nnothing to commit, working directory clean"
    },
    "pox": {
      "branch": "hb",
      "commit": "1ce3d8777c2a1bbaea68c4727a6f1ff59fe7a5d9",
      "diff": "diff --git a/pox/forwarding/l2_fwd.py b/pox/forwarding/l2_fwd.py\nindex 7b5e12f..27fa175 100644\n--- a/pox/forwarding/l2_fwd.py\n+++ b/pox/forwarding/l2_fwd.py\n@@ -261,6 +261,7 @@ class S2(EventMixin):\n       self.inconsistent_PacketIn(event)\n \n   def _handle_BarrierIn(self, event):\n+    raise RuntimeError()\n     self.log.info(\"BARRIER REPLY%s\", event.xid)\n     t = (self.dpid, event.xid)\n     if t in waiting_msgs:\n@@ -282,6 +283,10 @@ class Main(EventMixin):\n     self.consistent = consistent\n     self.use_barrier = use_barrier\n \n+    print \"CORE\", core\n+    print \"DIR core\", dir(core)\n+    print \"EVENT HANDLERS\", core._eventMixin_handlers\n+\n   def _handle_ConnectionUp (self, event):\n     log.debug(\"Connection %s\", event.connection)\n     dpid = dpidToStr(event.dpid)\n@@ -294,6 +299,10 @@ class Main(EventMixin):\n       self.handlers[s1].s2_conn = self.handlers[s2].s2_conn\n       self.handlers[s2].s1_conn = self.handlers[s1].s1_conn\n \n+    print \"CORE\", core\n+    print \"DIR core\", dir(core)\n+    print \"EVENT HANDLERS\", core._eventMixin_handlers\n+\n \n def launch(consistent=False, use_barrier=True):\n   core.registerNew(Main, consistent=str_to_bool(consistent),",
      "status": "On branch hb\nYour branch is up-to-date with 'origin/hb'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   pox/forwarding/l2_fwd.py\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tpox/forwarding/l2_multi_new.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    },
    "sts": {
      "branch": "hb",
      "commit": "d1c99a2e1141c4322ff1635f7c135c7730b9642c",
      "diff": "diff --git a/config/fuzzer_params.py b/config/fuzzer_params.py\nindex 1807a9a..e8b90ff 100644\n--- a/config/fuzzer_params.py\n+++ b/config/fuzzer_params.py\n@@ -11,7 +11,7 @@ link_failure_rate = 0.0\n link_recovery_rate = 1.0\n controller_crash_rate = 0.0\n controller_recovery_rate = 1.0\n-traffic_generation_rate = 0.10\n+traffic_generation_rate = 0.35\n host_migration_rate = 0.0\n intracontroller_block_rate = 0.0\n intracontroller_unblock_rate = 0.0\ndiff --git a/config/trace_floodlight_hb_learningswitch.py b/config/trace_floodlight_hb_learningswitch.py\nindex 16a1850..c069e84 100644\n--- a/config/trace_floodlight_hb_learningswitch.py\n+++ b/config/trace_floodlight_hb_learningswitch.py\n@@ -12,12 +12,12 @@ from config.application_events import AppCircuitPusher\n \n start_cmd = ('''java -ea -Dlogback.configurationFile=./src/main/resources/logback-trace.xml -jar '''\n              '''./target/floodlight.jar '''\n-              '''-cf ./src/main/resources/hb_learningswitch.properties''')\n+              '''-cf ./src/main/resources/learningswitch.properties''')\n \n # Uncomment this if you are running Floodlight separately, e.g. for debugging in Eclipse. There must be a controller listening on port 6633.\n-# start_cmd = '''echo \"no-op\"'''\n+start_cmd = '''echo \"no-op\"'''\n \n-controllers = [ControllerConfig(start_cmd, cwd='../floodlight', address=\"127.0.0.1\", port=6633)]\n+controllers = [ControllerConfig(start_cmd, cwd='../jfloodlight', address=\"192.168.56.1\", port=6633, controller_type='dummy')]\n \n \n \ndiff --git a/config/trace_pox_l2_consistency.py b/config/trace_pox_l2_consistency.py\nindex 4369691..84c9c84 100644\n--- a/config/trace_pox_l2_consistency.py\n+++ b/config/trace_pox_l2_consistency.py\n@@ -9,7 +9,7 @@ from sts.happensbefore.hb_logger import HappensBeforeLogger\n \n \n \n-consistent = True\n+consistent = False\n barriers= True\n \n # Use POX as our controller\ndiff --git a/pox b/pox\nindex 3f11583..1ce3d87 160000\n--- a/pox\n+++ b/pox\n@@ -1 +1 @@\n-Subproject commit 3f1158333a8ada3d3d310fb2cb1150caf011021a\n+Subproject commit 1ce3d8777c2a1bbaea68c4727a6f1ff59fe7a5d9-dirty\ndiff --git a/sts/happensbefore/hb_graph.py b/sts/happensbefore/hb_graph.py\nindex 95a0ebc..d1abafd 100755\n--- a/sts/happensbefore/hb_graph.py\n+++ b/sts/happensbefore/hb_graph.py\n@@ -32,6 +32,7 @@ from hb_events import *\n from hb_sts_events import *\n from hb_utils import dfs_edge_filter\n from hb_utils import just_mid_iter\n+from hb_utils import pretty_match\n \n #\n # Do not import any STS types! We would like to be able to run this offline\n@@ -98,6 +99,7 @@ class HappensBeforeGraph(object):\n     self.msgs = {}\n \n     self.alt_barr = alt_barr\n+    self.versions = {}\n \n   @property\n   def events(self):\n@@ -644,20 +646,14 @@ class HappensBeforeGraph(object):\n     \"\"\"\n     Adds proper annotation for the graph to make drawing it more pleasant.\n     \"\"\"\n-    def pretty_match(match):\n-      lines = match.show()\n-      output = ''\n-      for line in lines.split('\\n'):\n-        if not line.startswith('wildcards: '):\n-          output += line + ' '\n-      output = output.rstrip()\n-      if output == '':\n-        output = '*'\n-      return output.rstrip()\n-\n     for eid, data in g.nodes_iter(data=True):\n       event = data['event']\n       label = \"ID %d \\\\n %s\" % (eid, event.type)\n+      if hasattr(event, 'hid'):\n+        label += \"\\\\nHID: \" + str(event.hid)\n+      if hasattr(event, 'dpid'):\n+        label += \"\\\\nDPID: \" + str(event.dpid)\n+\n       shape = \"oval\"\n       op = None\n       if hasattr(event, 'operations'):\n@@ -666,6 +662,7 @@ class HappensBeforeGraph(object):\n             op = \"FlowTableWrite\"\n             op += \"\\\\nCMD: \" + OFP_COMMANDS[x.flow_mod.command]\n             op += \"\\\\nMatch: \" + pretty_match(x.flow_mod.match)\n+            op += \"\\\\nActions: \" + str(x.flow_mod.actions)\n             label += \"\\\\nt: \" + repr(x.t)\n             shape = 'box'\n             g.node[eid]['style'] = 'bold'\n@@ -678,14 +675,10 @@ class HappensBeforeGraph(object):\n       cmd_type = data.get('cmd_type')\n       if cmd_type:\n         label += \"\\\\n%s\" % cmd_type\n-      if op:\n-        label += \"\\\\nOp: %s\" % op\n-      if hasattr(event, 'hid'):\n-        label += \"\\\\nHID: \" + str(event.hid)\n-      if hasattr(event, 'dpid'):\n-        label += \"\\\\nDPID: \" + str(event.dpid)\n       if hasattr(event, 'msg_type'):\n         label += \"\\\\nMsgType: \" + event.msg_type_str\n+      if getattr(event, 'msg', None):\n+        label += \"\\\\nXID: %d\" % event.msg.xid\n       if hasattr(event, 'in_port'):\n         label += \"\\\\nInPort: \" + str(event.in_port)\n       if hasattr(event, 'out_port') and not isinstance(event.out_port, basestring):\n@@ -913,9 +906,33 @@ class HappensBeforeGraph(object):\n \n     return inconsistent_packet_traces, ignored_packet_traces, summarized\n \n+  def find_barrier_replies(self):\n+    barrier_replies = []\n+    for eid in self.msgs:\n+      if self.msgs[eid].msg_type_str != 'OFPT_BARRIER_REPLY':\n+        continue\n+      nodes = []\n+      edges = dfs_edge_filter(self.g, eid, just_mid_iter)\n+      for src, dst in edges:\n+        src_event = self.g.node[src]['event']\n+        dst_event = self.g.node[dst]['event']\n+        if isinstance(src_event, HbMessageHandle):\n+          nodes.append(src_event)\n+          #self.g.node[src]['cmd_type'] = \"Reactive to %d\" % eid\n+        if isinstance(dst_event, HbMessageHandle):\n+          nodes.append(dst_event)\n+          #self.g.node[dst]['cmd_type'] = \"Reactive to %d\" % eid\n+      # Get unique and sort by time\n+      nodes = sorted(list(set(nodes)),\n+                     key=lambda n: n.operations[0].t if n.operations else 0)\n+      barrier_replies.append((self.msgs[eid], nodes))\n+    return barrier_replies\n+\n   def find_reactive_versions(self):\n     cmds = []\n     for eid in self.msgs:\n+      if self.msgs[eid].msg_type_str == 'OFPT_BARRIER_REPLY':\n+        continue\n       nodes = []\n       edges = dfs_edge_filter(self.g, eid, just_mid_iter)\n       for src, dst in edges:\n@@ -969,11 +986,70 @@ class HappensBeforeGraph(object):\n     self.clustered_cmds = clustered_ordered\n     return clustered_ordered\n \n-  def find_inconsistent_updates(self):\n-    \"\"\"Try to find if two versions race with each other\"\"\"\n+  def find_versions(self):\n+    \"\"\"\n+    Find all versions, reactive or proactive\n+    \"\"\"\n+    if self.versions:\n+      return self.versions\n+\n     reactive = self.find_reactive_versions()\n     proactive = self.find_proactive_cmds(reactive)\n     self.cluster_cmds(proactive)\n+    # Consider all proactive and reactive versions\n+    versions = {}\n+    for version, events in self.clustered_cmds.iteritems():\n+      versions[version] = list(set([event.eid for event in events]))\n+    for pktin, events in reactive:\n+      versions[pktin] = list(set([event.eid for event in events]))\n+\n+    # Now merge versions if one contains a response to a barrier request\n+    # from previous version\n+    barrier_replies = self.find_barrier_replies()\n+    replies_by_xid = {} # (dpid, xid) -> cmds\n+    replies_by_xid_versions = {}  # (dpid, xid) -> versions\n+    requests_by_xid = {} # (dpid, xid) -> version\n+\n+    # Sort replies by dpid and xid\n+    for rep, cmds in barrier_replies:\n+      key = (rep.dpid, rep.msg.xid)\n+      replies_by_xid[key] = [event.eid for event in cmds]\n+      replies_by_xid_versions[key] = []\n+      reactive_cmds = set(replies_by_xid[key])\n+      for v, v_cmds in versions.iteritems():\n+        if reactive_cmds.intersection(v_cmds):\n+          replies_by_xid_versions[key].append(v)\n+\n+    # Sort requests by dpid and xid\n+    for v, v_cmds in versions.iteritems():\n+      for v_cmd in v_cmds:\n+        event = self.g.node[v_cmd]['event']\n+        if event.msg_type_str == 'OFPT_BARRIER_REQUEST':\n+          requests_by_xid[(event.dpid, event.msg.xid)] = v\n+\n+    for key, version in requests_by_xid.iteritems():\n+      if version not in versions:\n+        continue # already merged\n+      if key not in replies_by_xid:\n+        continue\n+      new_cmds = versions[version]\n+      for v in replies_by_xid_versions[key]:\n+        if v == version:\n+          continue # we already considered the first version\n+        if v not in versions:\n+          continue # already merged\n+        new_cmds += versions[v]\n+        del versions[v]\n+\n+    # Sort cmds by time, just to make it nicer\n+    for version in versions:\n+      versions[version].sort(key=lambda x: self.g.node[x]['event'].operations[0].t)\n+    self.versions = versions\n+    return versions\n+\n+  def find_inconsistent_updates(self):\n+    \"\"\"Try to find if two versions race with each other\"\"\"\n+    versions = self.find_versions()\n \n     ww_races = defaultdict(list)\n     for race in self.race_detector.races_harmful:\n@@ -981,13 +1057,6 @@ class HappensBeforeGraph(object):\n         ww_races[race.i_event.eid].append(race.k_event.eid)\n         ww_races[race.k_event.eid].append(race.i_event.eid)\n \n-    # Consider all proactive and reactive versions\n-    versions = {}\n-    for version, events in self.clustered_cmds.iteritems():\n-      versions[version] = set([event.eid for event in events])\n-    for pktin, events in reactive:\n-      versions[pktin] = set([event.eid for event in events])\n-\n     racing_events = []\n     for version, cmds in versions.iteritems():\n       for cmd in cmds:\n@@ -1078,6 +1147,20 @@ class Main(object):\n       self.graph.print_racing_packet_trace(*data, label='ignored')\n     self.graph.save_races_graph(self.print_pkt)\n \n+    versions = self.graph.find_versions()\n+    for v, cmds in versions.iteritems():\n+      print \"IN Version\", v\n+      if isinstance(v, HbMessageSend):\n+        print \"Msg: \", v.msg_type_str\n+      for cmd in cmds:\n+        node =  self.graph.g.node[cmd]['event']\n+        match = ''\n+        if getattr(node.msg, 'match', None):\n+          match = node.msg.show().replace('\\n', ' ')\n+        of_cmd = ''\n+        if hasattr(node.msg, 'command'):\n+          of_cmd = OFP_COMMANDS[node.msg.command]\n+        print \"\\t eid\", node.eid, \" dpid:\", node.dpid, \" xid:\", node.msg.xid , \" cmd:\", node.msg_type_str, of_cmd, ' ',  pretty_match(getattr(node.msg, 'match', None)), getattr(node.msg, 'actions', None)\n \n     print \"Number of packet inconsistencies: \", len(inconsistent_packet_traces)\n     print \"Number of packet inconsistencies after trimming repeated races: \", len(summarized)\ndiff --git a/sts/happensbefore/hb_utils.py b/sts/happensbefore/hb_utils.py\nindex c35800f..89660ea 100644\n--- a/sts/happensbefore/hb_utils.py\n+++ b/sts/happensbefore/hb_utils.py\n@@ -298,3 +298,27 @@ def rel_filter(G, source, rel):\n \n \n just_mid_iter = partial(rel_filter, rel='mid')\n+\n+\n+def pretty_match(match):\n+  if not match:\n+    return ''\n+  outstr = ''\n+  def append (f, formatter=str):\n+    v = match.__getattr__(f)\n+    if v is None: return ''\n+    return f + \": \" + formatter(v) + \" \"\n+  outstr = ''\n+  outstr += append('in_port')\n+  outstr += append('dl_src')\n+  outstr += append('dl_dst')\n+  outstr += append('dl_vlan')\n+  outstr += append('dl_vlan_pcp')\n+  outstr += append('dl_type')\n+  outstr += append('nw_tos')\n+  outstr += append('nw_proto')\n+  outstr += append('nw_src')\n+  outstr += append('nw_dst')\n+  outstr += append('tp_src')\n+  outstr += append('tp_dst')\n+  return outstr\n\\ No newline at end of file",
      "status": "On branch hb\nYour branch is up-to-date with 'origin/hb'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n  (commit or discard the untracked or modified content in submodules)\n\n\tmodified:   config/fuzzer_params.py\n\tmodified:   config/trace_floodlight_hb_learningswitch.py\n\tmodified:   config/trace_pox_l2_consistency.py\n\tmodified:   pox (new commits, modified content, untracked content)\n\tmodified:   sts/happensbefore/hb_graph.py\n\tmodified:   sts/happensbefore/hb_utils.py\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tconfig/pox_consistency.py\n\tconfig/trace_onos_hb_learningswitch.py\n\tgen.sh~\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "Ubuntu 15.04",
    "uname": "Linux stsdev 3.19.0-26-generic #28-Ubuntu SMP Tue Aug 11 14:16:32 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux"
  },
  "timestamp": "2015_09_21_18_14_22",
  "user": "ahassany"
}
